using System;
using System.Collections.Generic;
using System.Text;
using MemoryPack;

namespace Omni.Core.Cryptography
{
    [MemoryPackable]
    /// <summary>
    /// A secure token containing a payload, timestamp, and digital signature.
    /// </summary>
    public partial class Token
    {
        /// <summary>
        /// Key-value pairs containing custom data embedded in the token.
        /// Typically used to store user-related information or session metadata.
        /// </summary>
        public Dictionary<string, string> Payload { get; set; }

        /// <summary>
        /// The UTC timestamp indicating when the token was generated.
        /// </summary>
        public DateTime IssuedAt { get; set; }

        /// <summary>
        /// The UTC timestamp indicating when the token will expire.
        /// Tokens are considered invalid after this time.
        /// </summary>
        public DateTime Expiration { get; set; }

        /// <summary>
        /// The entity that issued the token (e.g., the backend service name).
        /// </summary>
        public string Issuer { get; set; }

        /// <summary>
        /// The digital signature (HMAC) used to verify the integrity and authenticity of the token.
        /// </summary>
        public byte[] Signature { get; set; } = null;
    }

    /// <summary>
    /// A class for generating secure tokens with payload, timestamp, and digital signature.
    /// </summary>
    public static class TokenGenerator
    {
        /// <summary>
        /// Gets or sets whether JSON is used to encode the token payload instead of the default binary serialization.
        /// </summary>
        public static bool UseJson { get; set; } = true;
        private const string k_DefaultIssuer = "OmniBackend";
        /// <summary>
        /// Generates a secure token with the specified payload and expiration time.
        /// </summary>
        /// <param name="payload">The payload to include in the token. If null, an empty payload is used.</param>
        /// <param name="expiration">The number of seconds until the token expires. Defaults to 24 hours.</param>
        /// <param name="issuer">The issuer of the token. Defaults to "OmniBackend".</param>
        /// <returns>The generated token as a base64 string.</returns>
        public static string Compute(Dictionary<string, string> payload = null, int expiration = 86400, string issuer = k_DefaultIssuer) // 24 hours
        {
            payload ??= new Dictionary<string, string>();
            Token token = new()
            {
                Payload = payload,
                IssuedAt = DateTime.UtcNow,
                Expiration = DateTime.UtcNow.AddSeconds(expiration),
                Issuer = issuer,
            };

            token.Signature = HmacGenerator.Compute(GetBinaryToken(token), NetworkManager.ProductionKey);
            return Convert.ToBase64String(GetBinaryToken(token));
        }

        /// <summary>
        /// Validates a secure token generated by <see cref="Compute"/>.
        /// </summary>
        /// <param name="uniqueToken">The secure token to validate.</param>
        /// <param name="token">The parsed token if validation was successful.</param>
        /// <param name="issuer">The expected issuer of the token. Defaults to "OmniBackend".</param>
        /// <returns>True if the token is valid and not expired; otherwise, false.</returns>
        public static bool Validate(string uniqueToken, out Token token, string issuer = k_DefaultIssuer)
        {
            try
            {
                token = UseJson ? NetworkManager.FromJson<Token>(Encoding.UTF8.GetString(Convert.FromBase64String(uniqueToken))) : NetworkManager.FromBinary<Token>(Convert.FromBase64String(uniqueToken));
                if (token.Issuer != issuer || token.Expiration < DateTime.UtcNow)
                    return false;

                byte[] checksum = token.Signature;
                token.Signature = null;

                bool isValid = HmacGenerator.Validate(GetBinaryToken(token), NetworkManager.ProductionKey, checksum);
                token.Signature = checksum;
                return isValid;
            }
            catch
            {
                token = null;
                return false;
            }
        }

        private static byte[] GetBinaryToken(Token token)
        {
            return UseJson ? Encoding.UTF8.GetBytes(NetworkManager.ToJson(token)) : NetworkManager.ToBinary(token);
        }
    }
}