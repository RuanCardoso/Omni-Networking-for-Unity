{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Tip</p> <p>If you plan to translate this documentation, it is recommended to use Google Chrome to avoid translation bugs and ensure accurate rendering of the content.</p> <p>Omni Networking is a powerful multiplayer networking solution for Unity games, offering high performance and extensive features. Key capabilities include:</p> <ul> <li>Efficient Data Management: Advanced synchronization and state management</li> <li>Flexible Communication: Multiple transport protocols and messaging systems</li> <li>Robust Security: Built-in encryption and authentication</li> <li>Optimized Performance: Binary serialization and data compression</li> <li>Developer-Friendly: Easy-to-use API and comprehensive tooling</li> </ul> <p>Whether you're creating competitive multiplayer games, co-op experiences, or massive multiplayer worlds, Omni provides the essential networking infrastructure you need.</p> <p>Data Storage</p> Feature Description Database Management Supports multiple relational databases through a built-in ORM (Object-Relational Mapping) system, enabling scalable, efficient, and secure data operations tailored for multiplayer environments. Compatible databases include:\u2022 Microsoft SQL Server\u2022 MySQL\u2022 MariaDB\u2022 PostgreSQL\u2022 Oracle\u2022 SQLite\u2022 FirebirdFeatures advanced querying capabilities, connection pooling, transaction management, and automatic migration support. The ORM provides a type-safe way to work with database entities while maintaining optimal performance for multiplayer scenarios. <p>Network Communication</p> Feature Description Network Variables Provides automated property synchronization between server and clients, eliminating the need for manual message handling. Ensures real-time data consistency across all networked instances with minimal code overhead. RPC (Remote Procedure Calls) Facilitates direct method invocation between clients and server, supporting both reliable and unreliable transmission modes. Enables synchronized execution of functions across the network with automatic parameter serialization. gRPC (Global RPC) Implements network-wide event broadcasting system for executing procedures across all connected clients simultaneously. Ideal for game-wide announcements, state updates, and synchronized events. Route Management Express.js-inspired routing system for organizing and handling network communications. Supports route parameters, middleware, and structured request/response patterns, enabling clean and maintainable network code architecture. Custom Messages Enables creation of custom message types for specialized network communication, supporting user-defined data structures and transmission formats. Offers flexibility for implementing unique network features and interactions. <p>Data Serialization &amp; Compression</p> Feature Description Binary Serialization Utilizes the <code>MemoryPack</code> library for efficient binary data serialization, minimizing data size for faster transmission and optimized network performance. JSON Serialization Uses the <code>Json.NET (Newtonsoft)</code> library for flexible and reliable JSON data serialization, ensuring compatibility with third-party services. Compression Leverages <code>Brotli</code> and <code>LZ4</code> algorithms to reduce data size, optimizing bandwidth usage and improving transmission speed. <p>Infrastructure &amp; Security</p> Feature Description Port Forwarding Facilitates NAT traversal and opens network ports using protocols like <code>PMP</code> and <code>UPnP</code>, ensuring seamless connectivity for multiplayer sessions. Cryptography Utilizes <code>AES</code> and <code>RSA</code> encryption algorithms to secure data transmission, ensuring protection of sensitive information across the network. Service Locator Implements a centralized registry for managing dependencies and services across networked objects, enabling efficient access to shared resources and components. Supports global and local service locators for flexible dependency management. Web Sockets Implements a lightweight and efficient WebSocket server for real-time communication between clients and server, supporting bidirectional data exchange and event-driven messaging. Http Server Implements a lightweight HTTP server for handling web requests, enabling web-based services and integrations within the multiplayer environment. Supports RESTful API design(Express.js-inspired) and custom route handling for versatile network communication. <p><code>Omni</code> requires Unity version <code>2021.3 or higher</code>, as it leverages the latest .NET Standard 2.1+ APIs to deliver optimal performance.</p> <p>Compatibility Table:</p> Unity Version Status Unity 2021.3 (LTS) \u2705 Fully Supported Unity 2022.3 (LTS) \u2705 Fully Supported Unity 2023.2 (Beta) \u2705 Fully Supported Unity 6000.0 (LTS) \u2705 Fully Supported <p>Warning</p> <p>Using versions not listed in the compatibility table may result in unexpected behavior or functionality issues. For the most reliable experience, please check the Releases page for up-to-date version compatibility information.</p>"},{"location":"#installation-via-package-manager","title":"Installation via Package Manager","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Unity 2021.3 or higher</li> <li>.NET Standard 2.1+ API Compatibility</li> </ul>"},{"location":"#quick-install","title":"Quick Install","text":"<ol> <li>Open Unity Package Manager (Window &gt; Package Manager)</li> <li>Click the <code>+</code> button in the top-left corner</li> <li>Select \"Add package from git URL\"</li> <li>Paste: <code>https://github.com/RuanCardoso/Omni-Networking-for-Unity.git</code></li> <li>Click \"Add\"</li> </ol> \ud83d\udce6 Included Dependencies <p>Core Libraries</p> <ul> <li>\u2728 Newtonsoft Json - Industry-standard JSON framework for .NET, providing robust serialization and deserialization capabilities</li> <li>\ud83d\ude80 MemoryPack - High-performance zero-allocation binary serializer optimized for gaming and real-time applications</li> <li>\u26a1 UniTask - Zero allocation async/await solution for Unity, delivering superior performance over standard coroutines</li> <li>\ud83c\udfaf DOTween - Fast and efficient animation engine for Unity with a fluent API and extensive feature set</li> </ul> <p>Database Connectors</p> <ul> <li>\ud83d\udcc1 SQLite - Self-contained, serverless, zero-configuration database engine perfect for local data storage</li> <li>\ud83d\udd0b MySqlConnector - High-performance, asynchronous MySQL database connector with connection pooling</li> <li>\ud83d\udc18 Npgsql - Open-source PostgreSQL database connector with full async support and advanced features</li> <li>\ud83d\udcca SQLKata - Elegant SQL query builder with support for multiple databases and complex queries</li> <li>and others depending on the database you choose.</li> </ul> <p>Networking</p> <ul> <li>\ud83c\udf10 LiteNetLib - Lightweight and fast UDP networking library with reliability, ordering, and connection management</li> <li>\ud83d\udd04 kcp2k - Reliable UDP communication protocol implementation offering low latency and congestion control</li> <li>\ud83d\udd12 BCrypt.Net - Modern cryptographic hashing for passwords with salt generation and verification</li> <li>\ud83d\udeaa Open.NAT - Port forwarding library supporting both UPnP and NAT-PMP for seamless multiplayer connectivity</li> </ul> <p>Development Tools</p> <ul> <li>\ud83d\udee0\ufe0f Humanizer - Developer utility for manipulating and formatting strings, enums, dates, times, and more</li> <li>\ud83c\udfa8 TriiInspector -  Advanced Unity inspector extension providing enhanced editor customization</li> <li>\ud83d\udd04 ParrelSync - Unity editor extension for testing multiplayer gameplay with multiple game instances locally</li> <li>\u26a1 Dapper - High-performance micro-ORM supporting SQL queries with strong typing and object mapping</li> <li>and others...</li> </ul>"},{"location":"#setup","title":"Setup","text":"<p>\ud83d\ude80 Introduction</p> <p>Build Defines</p> <p>Omni automatically configures the following build defines after package import:</p> Define Description <code>OMNI_RELEASE</code> Optimizes code for production. Disables logging, debugging features. Used when building the final game or server. <code>OMNI_DEBUG</code> Enables development detailed error information and runtime checks. Default for Unity Editor and Build. <code>OMNI_SERVER</code> Indicates a dedicated server build. Removes client-specific code, UI elements, and graphics rendering. <p>Common Imports</p> <p>Add these using directives to your scripts: C#<pre><code>using Omni.Core;      // Core functionality\nusing Omni.Inspector; // (Optional) - Unity inspector extensions\nusing Omni.Core.Web;  // (Optional) - Web and networking features\n</code></pre></p> <p>Conditional Compilation C#<pre><code>// Debug vs Release mode\n#if OMNI_DEBUG\n    Debug.Log(\"Development build\");\n#else\n    Debug.Log(\"Release build\");\n#endif\n\n// Client vs Server code\n#if OMNI_SERVER\n    // Server-only code\n    Debug.Log(\"Running on dedicated server\");\n#else\n    // Client-only code\n    Debug.Log(\"Running on client\");\n#endif\n</code></pre></p> <ol> <li>Go to the Unity Navigation Bar and select <code>Omni Networking</code>.</li> <li>Click the <code>Setup</code> menu item.</li> </ol> <p>A game object named <code>Network Manager</code> will be created in the scene. This object is responsible for the connection and contains all the network settings.</p> <p>Network Manager Requirements</p> <p>Required Configuration</p> <ul> <li>The <code>Network Manager</code> object must exist in your scene</li> <li>Do not destroy this object during runtime</li> <li>Do not rename this object</li> <li>Keep the default name: <code>Network Manager</code></li> </ul> <p>Common Issues</p> <p>If the <code>Network Manager</code> is missing or renamed:</p> <ul> <li>Network connections will fail</li> <li>Multiplayer features won't work</li> <li>Runtime errors will occur</li> </ul> <p>Network Manager Structure(Optional)</p> <p>Object Hierarchy</p> Text Only<pre><code>Network Manager (Main Object)\n\u251c\u2500\u2500 Client (Child Object)\n\u2514\u2500\u2500 Server (Child Object)\n</code></pre> <p>How It Works</p> <ul> <li>The <code>Network Manager</code> comes with two child objects: <code>Client</code> and <code>Server</code></li> <li>You can attach your networking scripts to these objects(Optional)</li> <li>During build:<ul> <li>Client build: Server scripts are removed</li> <li>Server build: Client scripts are removed</li> </ul> </li> </ul> <p>Warning</p> <p>This system only removes objects from the scene. The code still exists in the build.</p> <p>For complete code removal, use conditional compilation: C#<pre><code>#if OMNI_SERVER\n    // This code will be completely removed from client builds\n    void ServerOnlyMethod() {\n        // Server-specific code here\n    }\n#endif\n</code></pre></p> <ol> <li>Select the <code>Network Manager</code> object in the scene to view the network settings.</li> </ol> Option Description <code>Current Version</code> Displays the installed Omni version. Important for compatibility checks and troubleshooting. <code>Public IPv4</code> Your device's public IPv4 address. Updates automatically but can be refreshed manually <code>Public IPv6</code> Your device's public IPv6 address (if available). Used for modern network configurations. <code>GUID</code> Unique 128-bit identifier used for network authentication. Can be regenerated through context menu <p>Bug</p> <p>If the <code>Public IP</code> field displays an incorrect IP address, click the context menu of the <code>Network Manager</code> script and select Force Get Public Ip to update the field with the correct IP address. The correct IP address is essential for server identification and connection.</p> <p>Warning</p> <p>If the <code>GUID</code> between the client and server does not match, the connection will be refused. Ensure the <code>GUID</code> is correctly set in the <code>Network Manager</code> object to establish a successful connection. To update the <code>GUID</code>, click the context menu of the <code>Network Manager</code> script and select Generate GUID.</p>"},{"location":"#modules","title":"Modules","text":"Modules Description <code>Tick Module</code> Allows the use of a tick-based system for sending messages and other tick-based operations. <code>Sntp Module</code> Provides a high-precision synchronized clock between all clients and the server."},{"location":"#connection-settings","title":"Connection Settings","text":"Option Description <code>Server Port</code> The port number on which the server listens for incoming connections. <code>Client Port</code> The port number on which the client listens for incoming connections. Option Description <code>Host Address</code> A list of IP addresses that the client can connect to, the first address is used to connect. <code>Port</code> The port number on which the server is listening and which will be used for the connection."},{"location":"#configuration-options","title":"Configuration Options","text":"BasicAdvancedHTTP Server Option Description <code>Auto Start Client</code> When enabled, client automatically connects to server on scene load (Default: true) <code>Auto Start Server</code> When enabled, server automatically starts hosting on scene load (Default: true) <code>Tick Rate</code> Server update frequency in Hz. Higher values increase precision but consume more CPU (Default: 15) <code>Use UTF-8 Encoding</code> Uses UTF8 for string encoding. Enable for non-ASCII text support (Default: false) <code>Lock Client Fps</code> Limits client frame rate to reduce CPU/GPU load. Set to 0 for unlimited (Default: 60) Option Description <code>Pool Capacity</code> Maximum size in bytes for each network message buffer. Larger values consume more memory (Default: 32768) <code>Pool Size</code> Number of pre-allocated network buffers. Increase for high-traffic scenarios (Default: 32) <code>Use Unaligned Memory</code> Enables faster memory access on supported platforms. May cause issues on mobile (Default: false) <code>Enable Bandwidth Optimization</code> Enable bandwidth optimization for data transmission <code>Run In Background</code> Keep game running when window loses focus. Essential for server hosting (Default: true) Option Description <code>Enable Http Server</code> Activates REST API endpoint for external service integration (Default: false) <code>Enable Http Ssl</code> Enables HTTPS for secure API communication. Requires valid SSL certificate (Default: false) <code>Http Server Port</code> Port number for HTTP/HTTPS server. Common values: 80 (HTTP), 443 (HTTPS) (Default: 80)"},{"location":"#permissions","title":"Permissions","text":"Option Description <code>Allow NetVar's From Client</code> Determines whether client-side changes to network variables are permitted, allowing clients to modify networked variables directly. <code>Allow Across Group Message</code> Allows messages to be sent across different network groups, enabling communication between distinct groups in the network."},{"location":"#registered-prefabs","title":"Registered Prefabs","text":"<p>This list is used to automatically instantiate network objects. When a network object is instantiated by name or indexer, the object will be looked up in this list and instantiated automatically. Remember, manual instantiation is also available, and using this list is not required.</p>"},{"location":"#transporter-settings","title":"Transporter Settings","text":"<p>The Transporter Settings section allows you to configure various network transport parameters, including disconnection timeout, network event processing per frame, lag simulation, channel setup, IPv6 support, max connections, ping intervals, and more. Available options may vary based on the selected transporter.</p> <p>Currently, three transporters are supported: Lite Transporter, KCP Transporter, and Web Socket Transporter. Each transporter offers distinct features and capabilities, catering to different network requirements and scenarios.</p> Transporter ReliableOrdered Unreliable ReliableUnordered Sequenced ReliableSequenced Browser Compatibility Lite Transporter \u2705 \u2705 \u2705 \u2705 \u2705 \u274c Kcp Transporter \u2705 \u2705 \u274c \u274c \u274c \u274c Web Socket Transporter \u2705 \u274c \u274c \u274c \u274c \u2705 <p>Danger</p> <p>The KCP Transporter and Web Socket Transporter is currently experimental and may contain unresolved issues. Use it with caution and consider thoroughly testing for stability in your specific use case.</p> <p>Note</p> <p>By default, Omni utilizes the Lite Transporter for network operations. To switch to a different transporter, follow these steps:</p> <ol> <li>Remove the Lite Transporter: In your scene, locate the <code>Network Manager</code> object. Select it, and remove the <code>Lite Transporter</code> component from this object.</li> <li>Add the Desired Transporter: Once the Lite Transporter is removed, add the component of your preferred transporter to the <code>Network Manager</code> object.</li> </ol> <p>This configuration enables you to tailor network transport settings to suit the specific requirements of your project, ensuring optimal compatibility and performance.</p> <p>Warning</p> <p>Some properties or functions may be unavailable for certain transporters. If an incompatible option is used, an error message will appear to inform you of the mismatch.</p> <p>For detailed information on each transporter and their specific features, consult the respective documentation:</p> <ul> <li>LiteNetLib Documentation</li> <li>KCP Transporter (kcp2k) Documentation</li> </ul>"},{"location":"#known-issues","title":"Known Issues","text":"<p>IP Configuration</p> <p>The Issue</p> <ul> <li>When sharing your project, the <code>Public IP</code> field may show incorrect values</li> <li>This happens because IP addresses are stored in the scene file</li> </ul> <p>How to Fix</p> <ol> <li>Select the <code>Network Manager</code> in your scene</li> <li>Right-click on the component</li> <li>Choose <code>Force Get Public IP</code></li> </ol> <p>Note</p> <ul> <li>Your correct IP will be automatically fetched</li> <li>This step is required for proper network connections</li> <li>Remember to update IP when changing networks</li> </ul> <p>Installation Troubleshooting</p> <p>Common Issues</p> <ul> <li>Unity freezing during installation</li> <li>Missing macro definitions</li> <li>Package import errors</li> </ul> <p>How to Fix</p> <ol> <li> <p>Show hidden files in Windows:</p> <ul> <li>Open File Explorer</li> <li>View &gt; Show &gt; Hidden items</li> </ul> </li> <li> <p>Delete macro file:</p> <ul> <li>Go to: <code>Assets/Plugins/OmniNetworking</code></li> <li>Find: <code>omni_macros</code> file</li> <li>Delete it</li> </ul> </li> <li> <p>Restart Unity:</p> <ul> <li>Close Unity completely</li> <li>Reopen your project</li> <li>Package will regenerate macros</li> </ul> </li> </ol>"},{"location":"#communication-structure","title":"Communication Structure","text":"<p>The Omni framework is structured around four foundational classes designed for general communication. These classes implement methods and properties that simplify and expedite multiplayer functionalities, making the process both efficient and straightforward. Additionally, a \"low-level\" class is available for advanced communication, which should be utilized in contexts where restrictions or limitations apply, offering finer control for specialized cases.</p> <p>The Omni framework currently utilizes four base classes, each designed for different networking roles within the multiplayer structure. These classes include:</p>"},{"location":"#base-classes-overview","title":"Base Classes Overview","text":"Class Identity Required Usage <code>NetworkBehaviour</code> Yes For objects needing network identity (players, items) <code>ServerBehaviour</code> No Server-only logic (game state, matchmaking) <code>ClientBehaviour</code> No Client-only logic (UI, input handling, requests to server) <code>DualBehaviour</code> No Combined client/server logic <p>Each class serves a unique purpose in managing networked objects and handling server or client logic.</p>"},{"location":"#detailed-description","title":"Detailed Description","text":"NetworkBehaviourServerBehaviourClientBehaviourDualBehaviour <ul> <li>Purpose: Manage networked objects with unique identities</li> <li>Common Uses: <ul> <li>Player characters</li> <li>Interactable items</li> <li>Spawnable objects</li> </ul> </li> <li>Key Features:<ul> <li>Automatic synchronization</li> <li>Network identity management</li> <li>Object ownership</li> </ul> </li> </ul> <p>Object Registration</p> <p>Requirements</p> <ul> <li>Objects must be instantiated to work correctly with <code>NetworkBehaviour</code></li> </ul> <ul> <li>Purpose: Handle server-side logic</li> <li>Common Uses: <ul> <li>Game state management</li> <li>Player authentication</li> <li>Routing and messaging</li> <li>Callbacks and events</li> </ul> </li> <li>Key Features:<ul> <li>Server-only execution</li> <li>No network identity required</li> <li>Performance optimized</li> </ul> </li> </ul> <ul> <li>Purpose: Handle client-side logic</li> <li>Common Uses: <ul> <li>Requests to server-side logic and response handling</li> <li>UI management</li> <li>Callbacks and events</li> </ul> </li> <li>Key Features:<ul> <li>Client-only execution</li> <li>No network identity required</li> <li>Local processing</li> </ul> </li> </ul> <ul> <li>Purpose: Combined client/server logic</li> <li>Common Uses: <ul> <li>Shared game systems</li> <li>Unified managers</li> </ul> </li> <li>Key Features:<ul> <li>Both client/server code</li> <li>Conditional execution</li> <li>Code organization</li> </ul> </li> </ul> <p>This structured approach with these base classes simplifies multiplayer development, enabling clear separation of client and server responsibilities while providing flexibility for objects with and without identities.</p> <p>Behaviour Class Limitations</p> <p>Scene vs Spawned Objects</p> <ul> <li><code>ClientBehaviour</code>, <code>ServerBehaviour</code>, and <code>DualBehaviour</code>:<ul> <li>\u2705 Can be used on scene objects</li> <li>\u274c Cannot be spawned at runtime</li> <li>\u274c No NetworkIdentity support</li> </ul> </li> </ul> <p>Example Usage</p> C#<pre><code>// Correct: Scene object\npublic class GameManager : ServerBehaviour { }\npublic class LoginManager : ClientBehaviour { }\n\n// Wrong: Spawnable object\npublic class Player : ClientBehaviour { } // Won't work!!!!!\n// Correct alternative:\npublic class Player : NetworkBehaviour { } // Works as expected\n</code></pre> <p>Network Features Requirements</p> <p>Inheritance Required</p> <p>All scripts using network features must inherit from any:</p> <ul> <li><code>NetworkBehaviour</code></li> <li><code>ServerBehaviour</code></li> <li><code>ClientBehaviour</code></li> <li><code>DualBehaviour</code></li> </ul>"},{"location":"#network-identity","title":"Network Identity","text":"<p>The <code>NetworkIdentity</code> component is at the heart of the Omni networking high-level API. It controls a game object's unique identity on the network, and it uses that identity to make the networking system aware of the game object.</p> <p>The <code>NetworkIdentity</code> component is essential for network-aware GameObjects in Omni. It:</p> <ul> <li>Assigns unique identifiers to objects</li> <li>Enables network synchronization</li> <li>Manages object ownership</li> <li>Handles object spawning/despawning</li> </ul> <p>NetworkIdentity Nesting Rules</p> <p>Hierarchy Rules</p> <ul> <li>Only parent objects can have <code>NetworkIdentity</code></li> <li>Child objects cannot have <code>NetworkIdentity</code></li> <li>Children access parent's <code>NetworkIdentity</code> via <code>Identity</code> property</li> </ul> <p>Example Structure</p> Text Only<pre><code>Player (NetworkIdentity \u2705)\n\u251c\u2500\u2500 Weapon (NetworkIdentity \u274c)\n\u2514\u2500\u2500 Inventory (NetworkIdentity \u274c)\n</code></pre> <p>Code Example</p> C#<pre><code>// Parent object\npublic class Player : NetworkBehaviour {\n    // Has NetworkIdentity automatically\n}\n\n// Child object\npublic class Weapon : NetworkBehaviour {\n    void Start() {\n        // Access parent's NetworkIdentity\n        var parentIdentity = Identity;\n    }\n}\n</code></pre> <p>Common Error</p> <p>If you see: \"Multiple NetworkIdentity components in hierarchy\", check for duplicate components in child objects.</p> \ud83d\udd0d NetworkIdentity Properties <p>Properties:</p> Property Type Description <code>IdentityId</code> <code>int</code> Unique identifier used for network synchronization and object tracking <code>IsServer</code> <code>bool</code> Indicates if this instance is running on the server side <code>IsClient</code> <code>bool</code> Indicates if this instance is running on a client machine <code>IsLocalPlayer</code> <code>bool</code> Indicates if this object represents the local player on the local machine <code>IsServerOwner</code> <code>bool</code> Indicates if the server has authority over this objec <code>LocalPlayer</code> <code>NetworkIdentity</code> Reference to the local player's NetworkIdentity component <code>Owner</code> <code>NetworkPeer</code> Reference to the client that has authority over this object <code>IsRegistered</code> <code>bool</code> Indicates if this object is registered with the network system <p>LocalPlayer Assignment Rules</p> <p>Overview</p> <p>The <code>NetworkIdentity.LocalPlayer</code> property:</p> <ul> <li>Only available on client-side</li> <li>Requires specific naming conventions</li> <li>Auto-assigns based on prefab name or tag</li> </ul> <p>Valid Naming Patterns</p> <p>Prefab name must include \"Player\":</p> C#<pre><code>MyPlayer           // \u2705 Valid\nPlayerCharacter    // \u2705 Valid\nCharacter          // \u274c Invalid\n</code></pre> <p>Valid Tag Patterns</p> <p>GameObject tag must include \"Player\":</p> C#<pre><code>\"Player\"          // \u2705 Valid\n\"BluePlayer\"      // \u2705 Valid\n\"Character\"       // \u274c Invalid\n</code></pre> <p>Troubleshooting</p> <p>If <code>LocalPlayer</code> is null, check:</p> <ul> <li>Prefab name contains \"Player\"</li> <li>GameObject tag contains \"Player\"</li> <li>Script is running on client-side</li> </ul>"},{"location":"#service-locator-pattern","title":"Service Locator Pattern","text":"<p>The Service Locator pattern is a design pattern that provides a centralized registry or \"locator\" for retrieving instances of services or dependencies at runtime. This pattern allows for flexible dependency management and reduces the coupling between objects, making it ideal for complex applications like multiplayer games.</p> <p>Key Benefits of the Service Locator Pattern</p> <ul> <li>Centralized Access to Services: By acting as a central registry, the Service Locator allows different parts of the application to access services without tightly coupling dependencies.</li> <li>Flexible and Scalable: Services can be registered, replaced, or removed dynamically, providing flexibility for handling different networked components and systems in a multiplayer environment.</li> <li>Reduced Dependency on Singleton: Unlike the Singleton pattern, which can introduce issues in multiplayer setups (such as unwanted global state persistence), the Service Locator keeps services manageable and avoids potential conflicts.</li> <li>Improved Testing and Maintainability: The pattern facilitates testing and maintainability by allowing services to be swapped or mocked, which is crucial in a large multiplayer codebase.</li> </ul>"},{"location":"#service-locator-vs-singleton","title":"Service Locator vs. Singleton","text":"<p>While the Singleton pattern is commonly used to ensure only one instance of a class exists, it can lead to issues in multiplayer environments. Singletons often hold global state, which can interfere with networked instances and create unpredictable behavior, especially when managing player-specific data.</p> <p>Tip</p> <p>Omni recommends using the Service Locator pattern instead of Singletons for multiplayer development. The Service Locator provides better control over dependencies and avoids the pitfalls of global state inherent in Singletons, making it a more stable choice for complex networked systems.</p>"},{"location":"#usage-guide","title":"Usage Guide","text":"<p>By default, any script that inherits from a network class(<code>NetworkBehaviour</code>, <code>ServerBehaviour</code>, <code>ClientBehaviour</code>, <code>DualBehaviour</code> or <code>ServiceBehaviour</code>) is automatically registered in the Service Locator. This registration simplifies access to network services across your game's architecture. </p> <p>Service Naming and Customization</p> <ul> <li>Automatic Naming: Each service name is assigned automatically upon registration, based on the script's name.</li> <li>Customizable Names: You can modify the default service name directly in the Unity Inspector, allowing flexibility in organizing and identifying services as needed.</li> </ul> <p>Types of Service Locators in Omni</p> <p>Omni provides two types of Service Locators to manage service instances effectively within different scopes:</p> <ol> <li> <p>Global Service Locator: A shared Service Locator accessible across all networked instances. This global registry is ideal for managing universal services that need to be accessed by multiple objects or systems throughout the game.</p> </li> <li> <p>Local Service Locator: Each <code>NetworkIdentity</code> has its own local Service Locator, unique to that networked identity. allows you to retrieve specific services within the same identity, providing fine control over dependencies and enabling isolated management of services per networked object.</p> </li> </ol> <p>With this dual Service Locator approach, Omni offers a flexible, scalable structure that enhances dependency management in multiplayer environments, ensuring services are easily accessible while maintaining clear separation between global and local contexts.</p> Global Service LocatorLocal Service Locator C#<pre><code>// Example usage of the Global Service Locator\n// 1. Define your services\npublic class UIManager : ServiceBehaviour\n{ \n    public void ShowMenu() { }\n}\n\npublic class LoginManager : ClientBehaviour \n{ \n   public void Login() { }\n}\n\n// 2. Access services from anywhere\npublic class Player : NetworkBehaviour\n{\n   void Example()\n   {\n      // Accessing the `LoginManager` from the Global Service Locator\n      LoginManager loginManager = NetworkService.Get&lt;LoginManager&gt;();\n      loginManager.Login();\n\n      // Accessing the `UIManager` from the Global Service Locator with a custom name\n      UIManager uiManager = NetworkService.Get&lt;UIManager&gt;(\"MyUIManager\");\n      uiManager.ShowMenu();\n   }\n}\n</code></pre> C#<pre><code>// Example usage of the Local Service Locator\n// This script must be attached to the same networked object(`NetworkIdentity`).\n// 1. Define components on same GameObject\npublic class WeaponManager : NetworkBehaviour\n{ \n   public void Fire() { }\n}\n\npublic class PlayerManager : NetworkBehaviour\n{\n   void Example()\n   {\n      // Accessing the `WeaponManager` from the Local Service Locator using my own identity\n      // Get component from same NetworkIdentity\n      WeaponManager weaponManager = Identity.Get&lt;WeaponManager&gt;();\n      weaponManager.Fire();\n\n      // Get named component\n      var secondary = Identity.Get&lt;WeaponManager&gt;(\"SecondaryWeapon\");\n      secondary.Fire();\n   }\n}\n</code></pre> <p>Note</p> <p>The service locator can find services regardless of their depth within the hierarchy, ensuring accessibility even in deeply nested objects.</p> <p>Multiple Services</p> <p>When using multiple instances of same service:</p> <ol> <li>Set unique names in Inspector</li> <li>Use named lookup: C#<pre><code>// Get specific weapon manager\nvar pistol = Identity.Get&lt;WeaponManager&gt;(\"PistolManager\");\nvar rifle = Identity.Get&lt;WeaponManager&gt;(\"RifleManager\");\n</code></pre></li> </ol> <p>An exception will be thrown if the service is not found or if multiple instances of the same type have the same name.</p>"},{"location":"#with-dependency-injection","title":"With Dependency Injection","text":"C#<pre><code>// Example usage of the Global Service Locator with Dependency Injection\n// 1. Define your services\npublic class ServerManager : ServerBehaviour\n{ \n    public void SendAnnouncement(string message) { }\n} \n\npublic class WeaponManager : NetworkBehaviour\n{ \n    public void Fire() { }\n} \n\n// 2. Access services from anywhere\n// 3. Properties or fields are automatically injected by the Source Generator\npublic partial class Player : NetworkBehaviour\n{\n    [GlobalService]\n    private ServerManager serverManager; \n\n    [LocalService]\n    private WeaponManager weaponManager; \n\n    // named service\n    [LocalService(\"SecondaryWeapon\")]\n    private WeaponManager secondaryWeaponManager; \n\n    void Example()\n    {\n        // Accessing the `ServerManager` from the Global Service Locator\n        serverManager.SendAnnouncement(\"Hello, world!\"); \n\n        // Accessing the `WeaponManager` from the Local Service Locator\n        weaponManager.Fire();\n    }\n}\n</code></pre> <p>Dependency Injection Lifecycle</p> <p>When using dependency injection:</p> <ul> <li>Dependencies are NOT available in <code>Awake()</code></li> <li>Dependencies are available starting from <code>Start()</code> onwards</li> <li>Access services in <code>Awake()</code> manually if needed using <code>NetworkService.Get&lt;T&gt;()</code> or <code>Identity.Get&lt;T&gt;()</code></li> </ul> <p>Supported Classes</p> <p>Dependencies will only be injected in:</p> <ul> <li><code>NetworkBehaviour</code></li> <li><code>ClientBehaviour</code> and <code>ServerBehaviour</code></li> <li><code>DualBehaviour</code> and <code>ServiceBehaviour</code></li> <li>for other classes (like <code>MonoBehaviour</code>), use manual access</li> </ul> <p>Tip</p> <p>The Service Locator is designed to be fast and efficient, with minimal performance cost, unlike <code>GetComponent</code>, making it suitable for frequent use.</p> <p>See the API Reference for more information about the Service Locator and its usage.</p>"},{"location":"#build-deployment","title":"Build &amp; Deployment","text":""},{"location":"#build-guide","title":"Build Guide","text":"<p>When building your project for deployment, ensure the following steps are completed to ensure a successful multiplayer experience:</p> <p>Runtime Environment Configuration Guide</p> <p>Choose the optimal runtime setup for your client and server components:</p> <p>IL2CPP Client + Mono Server(Most Common Setup):</p> <p>\u2705 Benefits:</p> <ul> <li>Client: Enhanced performance and security through IL2CPP</li> <li>Server: Full .NET feature compatibility</li> <li>Faster development iteration cycles</li> </ul> <p>IL2CPP Server + Mono Client(Specialized Setup):</p> <p>\u26a0\ufe0f Considerations:</p> <ul> <li>Higher server performance but limited reflection and database capabilities</li> <li>Potential security risks with Mono client</li> <li>Not recommended for most applications</li> </ul> <p>Unified Runtime(Single Runtime Solution):</p> <p>IL2CPP Everywhere:</p> <ul> <li>Maximum performance</li> <li>Enhanced security</li> <li>More complex debugging process</li> <li>Limited reflection and database capabilities</li> </ul> <p>Mono Everywhere:</p> <ul> <li>Full .NET feature compatibility</li> <li>Better debugging experience</li> <li>Security risks on client side</li> </ul> Configuration Performance Security Development Ease IL2CPP Client + Mono Server \u2605\u2605\u2605\u2605\u2606 \u2605\u2605\u2605\u2605\u2606 \u2605\u2605\u2605\u2605\u2605 IL2CPP Server + Mono Client \u2605\u2605\u2605\u2606\u2606 \u2605\u2605\u2606\u2606\u2606 \u2605\u2605\u2605\u2606\u2606 All IL2CPP \u2605\u2605\u2605\u2605\u2605 \u2605\u2605\u2605\u2605\u2605 \u2605\u2605\u2605\u2606\u2606 All Mono \u2605\u2605\u2605\u2606\u2606 \u2605\u2605\u2606\u2606\u2606 \u2605\u2605\u2605\u2605\u2605 <p>Code Stripping for Client Security</p> <p>Always use conditional compilation to remove sensitive code from client builds:</p> C#<pre><code>#if OMNI_SERVER\n    // Server-only sensitive code here\n    private void ProcessSecureData() {\n        // This code will be stripped from client builds\n    }\n#endif\n</code></pre> <p>\u26a0\ufe0f Critical for Mono Clients: </p> <ul> <li>Mono builds have higher exposure to decompilation</li> <li>Code stripping is essential when using Mono client runtime</li> <li>Use <code>#if OMNI_SERVER</code> for:<ul> <li>Database credentials</li> <li>Security algorithms</li> <li>Server-side validation logic</li> <li>Administrative functions</li> </ul> </li> </ul> <p>Before building for deployment:</p> <ol> <li> <p>Switch to Release mode in Unity:</p> <ul> <li>Go to the Unity Navigation Bar</li> <li>Select <code>Omni Networking</code> and click <code>Change to Release</code></li> </ul> </li> <li> <p>Build your project:</p> <ul> <li>Go to <code>File -&gt; Build Settings</code></li> <li>Select your target platform</li> <li>Click <code>Build</code> to create the executable</li> </ul> </li> </ol> <p>Build Mode Reset Warning</p> <p>The build configuration will reset to DEBUG when:</p> <ul> <li>Switching to new target platforms</li> <li>Updating Omni version</li> <li>Switching Unity version</li> </ul> <p>This happens because each platform/version has unique preprocessor directives (#if).</p> <p>\u2714\ufe0f Always verify Release mode after:</p> <ul> <li>Platform changes</li> <li>Package updates</li> <li>Unity version changes</li> </ul> <p>To verify/fix:</p> <ol> <li>Open <code>Omni Networking -&gt; Change to Release</code></li> <li>Verify build settings are correct</li> </ol>"},{"location":"#deployment-guide","title":"Deployment Guide","text":"<p>When deploying your multiplayer game, consider the following best practices to ensure a smooth and secure experience for your players:</p> <p>Recommended Providers:</p> Provider Pros Starting Cost DigitalOcean Simple pricing, great for beginners $5/month Azure Strong .NET integration $15-20/month Google Cloud Good automation tools $10-15/month <p>Minimum VPS Requirements:</p> Bash<pre><code>CPU: 1 cores\nRAM: 1GB\nStorage: 50GB SSD\nNetwork: 10GB Bandwidth\nOS: Ubuntu 20.04 LTS\n</code></pre>"},{"location":"#setup-ubuntu-server","title":"Setup Ubuntu Server","text":"<p>After deploying your VPS, follow these steps to set up your Ubuntu server for hosting your multiplayer game:</p> <ol> <li> <p>Connect to Server via SSH:</p> <p>Open a terminal and use the following command to connect to your server:</p> Bash<pre><code>ssh -i your-key.pem user@server-ip\n\n# Example\nssh -i \"C:\\Users\\user\\Downloads\\my-key.pem\" admin@192.168.0.1\n</code></pre> <p>Maybe on your first connection, you may need to configure the root password.</p> </li> <li> <p>Update your Server:</p> <p>Run the following commands to update your server:</p> Bash<pre><code>sudo apt update\nsudo apt upgrade\nsudo apt install unzip -y\n</code></pre> </li> <li> <p>Database Setup (Optional):</p> <p>If your game requires a database, install MySQL/MariaDB or other database systems:</p> Bash<pre><code># Install MySQL\nsudo apt install mysql-server -y\n\n# Secure MySQL installation\nsudo mysql_secure_installation\n\n# Start MySQL service\nsudo systemctl start mysql\nsudo systemctl enable mysql\n</code></pre> <p>If you prefer MariaDB:</p> Bash<pre><code># Install MariaDB\nsudo apt install mariadb-server -y\n\n# Secure MariaDB installation\nsudo mysql_secure_installation\n\n# Start MariaDB service\nsudo systemctl start mariadb\nsydo systemctl enable mariadb\n</code></pre> <p>Database Security</p> <ul> <li>Use strong passwords (16+ characters)</li> <li>Only allow local connections by default</li> <li>Regularly backup your database:</li> </ul> <p>Backup Your Database:</p> Bash<pre><code># Access MySQL/MariaDB\nsudo mysql -u root -p\n\n# Backup your database\nmysqldump -u root -p my_database &gt; backup.sql\n\n# Restore your database\nmysql -u root -p my_database &lt; backup.sql\n</code></pre> </li> </ol>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#network-manager","title":"Network Manager","text":"<p>The <code>NetworkManager</code> class is the core component of the Omni Networking library for Unity. It provides a framework for managing network operations, including client-server communication, synchronization, and data transmission.</p> <p>The <code>NetworkManager</code> class is responsible for handling the initialization, configuration, and management of the network environment. It acts as a central hub for network-related operations, such as connecting to a server, handling client-server communication, and managing network events.</p>"},{"location":"api_reference/#methods","title":"Methods","text":""},{"location":"api_reference/#clearcaches","title":"ClearCaches","text":"<p>Clears all global caches, removing all entries from both append and overwrite cache collections.</p> <ul> <li>Signature: <code>public static void ClearCaches()</code></li> </ul> <p>Description</p> <p>The <code>ClearCaches</code> method removes all entries in the global append and overwrite cache collections. This method is useful for freeing up resources by clearing all cached data across the network, ensuring a clean state.</p> Example C#<pre><code>// Example of clearing all global caches\nNetworkManager.Server.ClearCaches();\nDebug.Log(\"All global caches have been cleared.\");\n</code></pre>"},{"location":"api_reference/#destroyallcaches","title":"DestroyAllCaches","text":"<p>Destroys all caches associated with the specified <code>NetworkPeer</code>, removing both global and overwrite caches marked for auto-destruction.</p> <ul> <li>Signature: <code>public static void DestroyAllCaches(NetworkPeer peer)</code></li> </ul> <p>Description</p> <p>The <code>DestroyAllCaches</code> method removes all cache entries associated with the given <code>NetworkPeer</code> that are marked for auto-destruction (<code>AutoDestroyCache</code>). This includes caches from both global append and global overwrite collections. If any cache entry fails to be removed, an error is logged.</p> <p>Parameters</p> Parameter Type Description <code>peer</code> <code>NetworkPeer</code> The network peer whose associated caches are to be destroyed. Example C#<pre><code>// Example of destroying all caches for a specific peer\nNetworkPeer clientPeer = GetClientPeer(); // Hypothetical method to get a client peer\nNetworkManager.Server.DestroyAllCaches(clientPeer);\nDebug.Log($\"Destroyed all auto-destroy caches for peer {clientPeer.Id}\");\n</code></pre>"},{"location":"api_reference/#deletecache","title":"DeleteCache","text":"<p>Deletes a cache entry based on the provided <code>DataCache</code> and optional <code>groupId</code>, or a <code>DataCache</code> associated with a specific <code>NetworkPeer</code>.</p> <ul> <li>Signature:</li> <li><code>public static void DeleteCache(DataCache dataCache, int groupId = 0)</code></li> <li><code>public static void DeleteCache(DataCache dataCache, NetworkPeer peer, int groupId = 0)</code></li> </ul> <p>Description</p> <p>The <code>DeleteCache</code> methods remove cache entries based on the provided <code>DataCache</code> details. Depending on the cache's <code>Mode</code>, this can involve removing global, group-specific, or peer-specific caches, with additional conditions to check if the <code>DataCache.Id</code> and <code>DataCache.Mode</code> are set correctly. These methods ensure the removal of specified caches, either by targeting a particular group (<code>groupId</code>) or by associating it with a specific peer (<code>NetworkPeer</code>).</p> <p>Parameters</p> Parameter Type Description <code>dataCache</code> <code>DataCache</code> The data cache to delete, which includes mode and ID for the targeted cache entry. <code>groupId</code> <code>int</code> The ID of the group to which the cache belongs (optional, default is <code>0</code>). <code>peer</code> <code>NetworkPeer</code> The peer associated with the cache, for peer-specific cache deletion. <p>Overloads</p> DeleteCache (DataCache dataCache, int groupId = 0)DeleteCache (DataCache dataCache, NetworkPeer peer, int groupId = 0) <p>Deletes a cache entry in a specific group or globally based on the provided <code>DataCache</code> and <code>groupId</code>.</p> Parameter Type Description <code>dataCache</code> <code>DataCache</code> The data cache to delete. <code>groupId</code> <code>int</code> The ID of the group to which the cache belongs. Example Example C#<pre><code>// Example of deleting a cache entry in a specific group\nDataCache cacheToDelete = new DataCache(CachePresets.ServerNew);\nNetworkManager.Server.DeleteCache(cacheToDelete, groupId: 5);\n</code></pre> <p>Deletes a cache entry for a specific peer or group based on the provided <code>DataCache</code>, <code>NetworkPeer</code>, and optional <code>groupId</code>.</p> Parameter Type Description <code>dataCache</code> <code>DataCache</code> The data cache to delete. <code>peer</code> <code>NetworkPeer</code> The peer associated with the cache. <code>groupId</code> <code>int</code> The ID of the group to which the cache belongs. Example Example C#<pre><code>// Example of deleting a peer-specific cache entry\nDataCache cacheToDelete = new DataCache(CachePresets.ServerNew);\nNetworkManager.Server.DeleteCache(cacheToDelete, peer, groupId: 3);\n</code></pre>"},{"location":"api_reference/#invokeserver-by-instance","title":"Invoke(Server) by Instance","text":"<p>Invokes a Remote Procedure Call (RPC) on clients, targeting a specific network identity and script instance by their IDs, with customizable options for target, delivery mode, grouping, and sequencing.</p> <ul> <li>Signature:</li> <li><code>public static void Invoke(byte msgId, NetworkPeer peer, int identityId, byte instanceId, SyncOptions options)</code></li> <li><code>public static void Invoke(byte msgId, NetworkPeer peer, int identityId, byte instanceId, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>Invoke</code> method allows the server to execute a specific RPC on clients by targeting a <code>NetworkIdentity</code> and a specific script instance associated with that identity. The <code>identityId</code> identifies the object, while <code>instanceId</code> specifies the exact script instance on that object that should receive the RPC. This function provides options for message delivery such as buffer, target recipients, delivery reliability, grouping, and sequencing.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The unique ID of the <code>NetworkIdentity</code> that will receive the RPC. <code>instanceId</code> <code>byte</code> The ID of the script instance on the <code>NetworkIdentity</code> that will receive the RPC. <code>options</code> <code>SyncOptions</code> A set of options for synchronization (used in the first overload). <code>buffer</code> <code>DataBuffer</code> Optional data buffer to send. <code>target</code> <code>Target</code> Specifies the target for the RPC, such as all clients or a specific peer (default is <code>All</code>). <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code> (default), <code>Unreliable</code>, etc. <code>groupId</code> <code>int</code> ID for grouping related messages together (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Cache option for the data being sent (default is <code>DataCache.None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing to manage order consistency across channels (default is <code>0</code>). <p>Overloads</p> Invoke (byte msgId, NetworkPeer peer, int identityId, byte instanceId, SyncOptions options)Invoke (byte msgId, NetworkPeer peer, int identityId, byte instanceId, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0) <p>Invokes an RPC using <code>SyncOptions</code> to specify buffer, target, delivery mode, group ID, data cache, and sequence channel, targeting both a <code>NetworkIdentity</code> and script instance.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The ID of the <code>NetworkIdentity</code> to target. <code>instanceId</code> <code>byte</code> The ID of the script instance to target. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example Example C#<pre><code>// Example of invoking an RPC with SyncOptions targeting a specific identity and script instance\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    Target = Target.Self,\n    DeliveryMode = DeliveryMode.Unreliable,\n    GroupId = 0,\n    DataCache = DataCache.None,\n    SequenceChannel = 0\n};\nNetworkManager.Server.Invoke(1, clientPeer, identityId: 101, instanceId: 5, syncOptions);\n</code></pre> <p>Invokes an RPC with detailed parameters for buffer, target, delivery mode, grouping, and sequencing, targeting both a <code>NetworkIdentity</code> and script instance.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The ID of the <code>NetworkIdentity</code> to target. <code>instanceId</code> <code>byte</code> The ID of the script instance to target. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>target</code> <code>Target</code> The target for the RPC, such as all clients or a specific peer. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>groupId</code> <code>int</code> ID for grouping related messages (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Specifies how the message data is cached (default is <code>None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example Example C#<pre><code>// Example of invoking an RPC targeting a specific identity and script instance with detailed parameters(optional)\nNetworkManager.Server.Invoke(\n    1,\n    clientPeer,\n    identityId: 101,\n    instanceId: 5,\n    buffer: myDataBuffer,\n    target: Target.All,\n    deliveryMode: DeliveryMode.Unreliable,\n    groupId: 0,\n    dataCache: DataCache.None,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Identity and Instance-Specific Invocation: Targets a specific <code>NetworkIdentity</code> using <code>identityId</code> and a specific script instance using <code>instanceId</code>, ensuring precise correspondence with the intended script or object.</li> <li>Flexible Targeting: Supports targeting all clients, server-only, or specific peers, providing control over who receives the RPC.</li> <li>Reliability Options: Provides reliable, ordered delivery or lightweight, unordered options depending on the use case.</li> <li>Sequencing and Grouping: Allows message organization with group IDs and sequence channels, ensuring consistency across channels.</li> <li>Usage: Ideal for invoking RPCs on specific entities and script instances, particularly for commands or updates that are relevant to targeted objects or specific components.</li> </ul> <p>Note</p> <p>This function is also available on the <code>client side</code>, but does not load the <code>peer</code> parameter.</p>"},{"location":"api_reference/#invokeserver","title":"Invoke(Server)","text":"<p>Invokes a Remote Procedure Call (RPC) on clients, targeting a specific network identity by its unique ID, with options for target, delivery mode, grouping, and sequencing.</p> <ul> <li>Signature:</li> <li><code>public static void Invoke(byte msgId, NetworkPeer peer, int identityId, SyncOptions options)</code></li> <li><code>public static void Invoke(byte msgId, NetworkPeer peer, int identityId, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>Invoke</code> method allows the server to execute a specific RPC on clients by using the unique <code>identityId</code> of a network identity. Unlike global RPCs, this method requires the identity ID to establish correspondence, ensuring that only scripts or objects tied to that identity will respond. This method offers flexibility for customizing message delivery with options such as buffer, target recipients, delivery reliability, grouping, and message sequencing.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The unique ID of the <code>NetworkIdentity</code> that will receive the RPC. <code>options</code> <code>SyncOptions</code> A set of options for synchronization (used in the first overload). <code>buffer</code> <code>DataBuffer</code> Optional data buffer to send. <code>target</code> <code>Target</code> Specifies the target for the RPC, such as all clients or a specific peer (default is <code>All</code>). <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code> (default), <code>Unreliable</code>, etc. <code>groupId</code> <code>int</code> ID for grouping related messages together (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Cache option for the data being sent (default is <code>DataCache.None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing to manage order consistency across channels (default is <code>0</code>). <p>Overloads</p> Invoke (byte msgId, NetworkPeer peer, int identityId, SyncOptions options)Invoke (byte msgId, NetworkPeer peer, int identityId, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0) <p>Invokes an RPC using a <code>SyncOptions</code> instance to specify buffer, target, delivery mode, group ID, data cache, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The ID of the <code>NetworkIdentity</code> to target. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example Example C#<pre><code>// Example of invoking an RPC with SyncOptions targeting a specific identity\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    Target = Target.Self,\n    DeliveryMode = DeliveryMode.Unreliable,\n    GroupId = 0,\n    DataCache = DataCache.None,\n    SequenceChannel = 0\n};\nNetworkManager.Server.Invoke(1, clientPeer, identityId: 101, syncOptions);\n</code></pre> <p>Invokes an RPC with detailed parameters for buffer, target, delivery mode, grouping, and sequencing.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>identityId</code> <code>int</code> The ID of the <code>NetworkIdentity</code> to target. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>target</code> <code>Target</code> The target for the RPC, such as all clients or a specific peer. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>groupId</code> <code>int</code> ID for grouping related messages (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Specifies how the message data is cached (default is <code>None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example Example C#<pre><code>// Example of invoking an RPC targeting a specific identity with detailed parameters(optional)\nNetworkManager.Server.Invoke(\n    1,\n    clientPeer,\n    identityId: 101,\n    buffer: myDataBuffer,\n    target: Target.All,\n    deliveryMode: DeliveryMode.Unreliable,\n    groupId: 0,\n    dataCache: DataCache.None,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Identity-Specific Invocation: Targets a specific <code>NetworkIdentity</code> using <code>identityId</code>, ensuring the RPC is directed only to matching identities.</li> <li>Flexible Targeting: Supports targeting all clients, server-only, or specific peers, allowing control over who receives the RPC.</li> <li>Reliability Options: Provides reliable, ordered delivery or lightweight, unordered options depending on the use case.</li> <li>Sequencing and Grouping: Allows message organization with group IDs and sequence channels, ensuring consistency across channels.</li> <li>Usage: Ideal for invoking RPCs on specific entities across clients, especially for commands that are only relevant to targeted objects or scripts.</li> </ul> <p>Note</p> <p>This function is also available on the <code>client side</code>, but does not load the <code>peer</code> parameter.</p>"},{"location":"api_reference/#globalinvokeserver","title":"GlobalInvoke(Server)","text":"<p>Invokes a global Remote Procedure Call (RPC) on clients, independent of script instance or identity, using customizable options for target, delivery mode, grouping, and sequencing.</p> <ul> <li>Signature:</li> <li><code>public static void GlobalInvoke(byte msgId, NetworkPeer peer, SyncOptions options)</code></li> <li><code>public static void GlobalInvoke(byte msgId, NetworkPeer peer, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>GlobalInvoke</code> method allows the server to invoke a global RPC on connected clients. Unlike instance-based RPCs, <code>GlobalInvoke</code> does not require a specific script instance or identity, allowing any client-side script with the matching RPC to be called directly. This is ideal for general-purpose commands and broadcasts. The method offers flexible parameters for controlling the target recipients, delivery reliability, grouping, and message sequencing.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer for whom the RPC is invoked. <code>options</code> <code>SyncOptions</code> A set of options for synchronization (used in the first overload). <code>buffer</code> <code>DataBuffer</code> Optional data buffer to send. <code>target</code> <code>Target</code> Specifies the target for the RPC, such as all clients or a specific peer (default is <code>All</code>). <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code> (default), <code>Unreliable</code>, etc. <code>groupId</code> <code>int</code> ID for grouping related messages together (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Cache option for the data being sent (default is <code>DataCache.None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing to manage order consistency across channels (default is <code>0</code>). <p>Overloads</p> GlobalInvoke (byte msgId, NetworkPeer peer, SyncOptions options)GlobalInvoke (byte msgId, NetworkPeer peer, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0) <p>Invokes an RPC on clients using a <code>SyncOptions</code> instance to specify buffer, target, delivery mode, group ID, data cache, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer to whom the RPC is invoked. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example Example C#<pre><code>// Example of invoking a global RPC with SyncOptions\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    Target = Target.All,\n    DeliveryMode = DeliveryMode.Reliable,\n    GroupId = 0,\n    DataCache = DataCache.None,\n    SequenceChannel = 0\n};\nNetworkManager.Server.GlobalInvoke(1, clientPeer, syncOptions);\n</code></pre> <p>Invokes an RPC on clients with detailed parameters for buffer, target, delivery mode, grouping, and sequencing.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the RPC message to invoke. <code>peer</code> <code>NetworkPeer</code> The peer to whom the RPC is invoked. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>target</code> <code>Target</code> The target for the RPC, such as all clients or a specific peer. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>groupId</code> <code>int</code> ID for grouping related messages (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Specifies how the message data is cached (default is <code>None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example Example C#<pre><code>// Example of invoking a global RPC with detailed parameters(optional)\nNetworkManager.Server.GlobalInvoke(\n    1,\n    clientPeer,\n    buffer: myDataBuffer,\n    target: Target.Self,\n    deliveryMode: DeliveryMode.Reliable,\n    groupId: 0,\n    dataCache: DataCache.None,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Global Invocation: Unlike instance-specific RPCs, <code>GlobalInvoke</code> targets clients globally, without needing script identity or instance details.</li> <li>Flexible Targeting: Supports targeting all clients, server-only, or specific peers, allowing flexible control over who receives the RPC.</li> <li>Reliability Options: Provides reliable, ordered delivery or lightweight, unordered options depending on the use case.</li> <li>Sequencing and Grouping: Allows message organization with group IDs and sequence channels, ensuring consistency across channels.</li> <li>Usage: Ideal for broadcasting general-purpose commands or notifications across clients without binding to specific instances.</li> </ul> <p>Note</p> <p>This function is also available on the <code>client side</code>, but does not load the <code>peer</code> parameter.</p>"},{"location":"api_reference/#trygetidentity","title":"TryGetIdentity","text":"<p>Attempts to retrieve a <code>NetworkIdentity</code> instance by its unique identity ID.</p> <ul> <li>Signature: <code>public static bool TryGetIdentity(int identityId, out NetworkIdentity identity)</code></li> </ul> <p>Description</p> <p>The <code>TryGetIdentity</code> method searches for a <code>NetworkIdentity</code> in the networked identities collection using a unique <code>identityId</code>. If the <code>NetworkIdentity</code> is found, it is returned via the <code>out</code> parameter; otherwise, <code>null</code> is returned. This method provides a safe and efficient way to check if an identity exists before attempting to interact with it.</p> <p>Parameters</p> Parameter Type Description <code>identityId</code> <code>int</code> The unique ID of the <code>NetworkIdentity</code> to retrieve. <code>identity</code> <code>NetworkIdentity</code> The retrieved <code>NetworkIdentity</code> instance, or <code>null</code> if not found. <p>Returns</p> <ul> <li><code>bool</code>: Returns <code>true</code> if the <code>NetworkIdentity</code> was found; otherwise, <code>false</code>.</li> </ul> Example C#<pre><code>// Example of retrieving a NetworkIdentity by its unique ID on the server\nint identityId = 101;\nif (NetworkManager.Server.TryGetIdentity(identityId, out NetworkIdentity networkIdentity))\n{\n    Debug.Log($\"NetworkIdentity with ID {identityId} found: {networkIdentity.name}\");\n}\nelse\n{\n    Debug.Log($\"NetworkIdentity with ID {identityId} not found.\");\n}\n\n// Example of retrieving a NetworkIdentity by its unique ID on the client\nif (NetworkManager.Client.TryGetIdentity(identityId, out NetworkIdentity networkIdentity))\n{\n    Debug.Log($\"NetworkIdentity with ID {identityId} found: {networkIdentity.name}\");\n}\nelse\n{\n    Debug.Log($\"NetworkIdentity with ID {identityId} not found.\");\n}\n</code></pre>"},{"location":"api_reference/#addprefab","title":"AddPrefab","text":"<p>Adds a prefab to the NetworkManager's registration list if it hasn\u2019t been registered already.</p> <ul> <li>Signature: <code>public static void AddPrefab(NetworkIdentity prefab)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to add to the registration list. <p>Description</p> <p>Registers a <code>NetworkIdentity</code> prefab for network spawning. This method checks if a prefab with the same name already exists in the list, and if so, it will not add it again. This ensures that each prefab is unique in the registration list.</p> Example C#<pre><code>   // Example of adding a prefab to the registration list\n   NetworkManager.AddPrefab(myPrefabIdentity);\n</code></pre>"},{"location":"api_reference/#getprefab","title":"GetPrefab","text":"<p>Retrieves a prefab from the NetworkManager's registered list by either its name or index.</p> <ul> <li>Signature: </li> <li><code>public static NetworkIdentity GetPrefab(string prefabName)</code></li> <li><code>public static NetworkIdentity GetPrefab(int index)</code></li> </ul> GetPrefab (string prefabName)GetPrefab (int index) <p>Retrieves a prefab by its name.</p> Parameter Type Description <code>prefabName</code> <code>string</code> The name of the prefab to retrieve. <ul> <li>Returns: <code>NetworkIdentity</code> \u2014 The prefab with the specified name.</li> <li>Exceptions: Throws an <code>Exception</code> if the prefab with the specified name is not found.</li> </ul> Example Example C#<pre><code>   // Example of retrieving a prefab by name\n   try\n   {\n       NetworkIdentity playerPrefab = NetworkManager.GetPrefab(\"Player\");\n       Debug.Log(\"Prefab retrieved successfully by name.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre> <p>Retrieves a prefab by its index in the registered list.</p> Parameter Type Description <code>index</code> <code>int</code> The index of the prefab to retrieve in the list. <ul> <li>Returns: <code>NetworkIdentity</code> \u2014 The prefab at the specified index.</li> <li>Exceptions: Throws an <code>IndexOutOfRangeException</code> if the index is out of bounds.</li> </ul> Example Example C#<pre><code>   // Example of retrieving a prefab by index\n   try\n   {\n       NetworkIdentity enemyPrefab = NetworkManager.GetPrefab(0);\n       Debug.Log(\"Prefab retrieved successfully by index.\");\n   }\n   catch (IndexOutOfRangeException ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre> <p>Description</p> <p>This method provides two overloads for retrieving a <code>NetworkIdentity</code> prefab from the NetworkManager\u2019s registration list. You can either search by the name of the prefab or by its index within the list. If a matching prefab is found, it is returned; otherwise, an appropriate exception is thrown, ensuring that only registered prefabs are used for network spawning.</p> <p>Remarks</p> <ul> <li>By Name: Throws an <code>Exception</code> if the prefab with the specified name is not found in the registration list.</li> <li>By Index: Throws an <code>IndexOutOfRangeException</code> if the index is out of bounds.</li> <li>Useful for scenarios where dynamic instantiation of networked objects is required, either by specific name or by predefined order in the list.</li> </ul>"},{"location":"api_reference/#connect","title":"Connect","text":"<p>Establishes a connection to a specified server address and port. There are two overloads for this method, allowing you to specify a client listening port if needed.</p> <ul> <li>Signature:</li> <li><code>public static void Connect(string address, int port)</code></li> <li><code>public static void Connect(string address, int port, int listenPort)</code></li> </ul> Connect (string address, int port)Connect (string address, int port, int listenPort) <p>Connects to the server using the specified <code>address</code> and <code>port</code>. The client will use the default listening port defined in <code>Manager.m_ClientListenPort</code>.</p> Parameter Type Description <code>address</code> <code>string</code> The IP address of the server. <code>port</code> <code>int</code> The port number on the server. <ul> <li>Exceptions: Throws an <code>Exception</code> if the client is already active, instructing to stop the client before reconnecting.</li> </ul> Example Example C#<pre><code>// Connect to a server with default client listening port\nNetworkManager.Connect(\"192.168.1.1\", 7777);\n</code></pre> <p>Connects to the server using the specified <code>address</code> and <code>port</code>, with the client listening on the specified <code>listenPort</code>.</p> Parameter Type Description <code>address</code> <code>string</code> The IP address of the server. <code>port</code> <code>int</code> The port number on the server. <code>listenPort</code> <code>int</code> The port number on which the client listens. <ul> <li>Exceptions: Throws an <code>Exception</code> if the client is already active, instructing to stop the client before reconnecting.</li> </ul> Example Example C#<pre><code>// Connect to a server with a custom client listening port\nNetworkManager.Connect(\"192.168.1.1\", 7777, 8888);\n</code></pre> <p>Description</p> <p>The <code>Connect</code> method initiates a connection to the server at a given IP address and port. If the client is already active, an exception is thrown to prevent multiple connections. In the server build configuration (<code>UNITY_SERVER</code>), client connections are disabled.</p> <p>Remarks</p> <ul> <li>Server Build: In a server build (<code>UNITY_SERVER</code>), client connections are not permitted and will log a message instead.</li> <li>Exception Handling: Ensure to call <code>StopClient()</code> before reconnecting if the client is already active to avoid exceptions.</li> <li>Listening Port: Use the overload with <code>listenPort</code> if a custom listening port is required for the client.</li> </ul>"},{"location":"api_reference/#disconnectpeer","title":"DisconnectPeer","text":"<p>Disconnects a specified peer from the server.</p> <ul> <li>Signature: <code>public static void DisconnectPeer(NetworkPeer peer)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>peer</code> <code>NetworkPeer</code> The network peer to disconnect. <p>Description</p> <p>The <code>DisconnectPeer</code> method removes the specified <code>NetworkPeer</code> from the server if the server is currently active. If the server has not been initialized, an exception is thrown to prompt server startup before disconnection.</p> Example C#<pre><code>   // Example of disconnecting a peer\n   try\n   {\n       NetworkPeer somePeer = GetPeer(); // Assume this retrieves a valid NetworkPeer\n       NetworkManager.DisconnectPeer(somePeer);\n       Debug.Log(\"Peer disconnected successfully.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre>"},{"location":"api_reference/#disconnect","title":"Disconnect","text":"<p>Disconnects the local client from the server.</p> <ul> <li>Signature: <code>public static void Disconnect()</code></li> </ul> <p>Description</p> <p>The <code>Disconnect</code> method terminates the connection between the local client and the server, if the client is currently active. If the client has not been initialized, an exception is thrown to prompt a connection attempt before disconnection.</p> Example C#<pre><code>   // Example of disconnecting the client from the server\n   try\n   {\n       NetworkManager.Disconnect();\n       Debug.Log(\"Client disconnected successfully.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre>"},{"location":"api_reference/#stopclient","title":"StopClient","text":"<p>Stops the local client and ends its connection to the server.</p> <ul> <li>Signature: <code>public static void StopClient()</code></li> </ul> <p>Description</p> <p>The <code>StopClient</code> method halts the local client\u2019s network operations, fully disconnecting it from the server if it is currently active. If the client has not been initialized, an exception is thrown to prompt a connection attempt before stopping.</p> Example C#<pre><code>   // Example of stopping the client\n   try\n   {\n       NetworkManager.StopClient();\n       Debug.Log(\"Client stopped successfully.\");\n   }\n   catch (Exception ex)\n   {\n       Debug.LogError(ex.Message);\n   }\n</code></pre>"},{"location":"api_reference/#fastwrite","title":"FastWrite","text":"<p>Writes one or more primitive values to a <code>DataBuffer</code>, utilizing <code>stackalloc</code> to avoid allocations and ensure high performance. This method is available in multiple overloads, allowing for writing up to six primitive values in a single call.</p> <ul> <li>Signature:</li> <li><code>public static DataBuffer FastWrite&lt;T1&gt;(T1 t1) where T1 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2&gt;(T1 t1, T2 t2) where T1 : unmanaged where T2 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3&gt;(T1 t1, T2 t2, T3 t3) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3, T4&gt;(T1 t1, T2 t2, T3 t3, T4 t4) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3, T4, T5&gt;(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged where T5 : unmanaged</code></li> <li><code>public static DataBuffer FastWrite&lt;T1, T2, T3, T4, T5, T6&gt;(T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) where T1 : unmanaged where T2 : unmanaged where T3 : unmanaged where T4 : unmanaged where T5 : unmanaged where T6 : unmanaged</code></li> </ul> <p>Description</p> <p>Each overload of <code>FastWrite</code> allows for writing up to six unmanaged primitive values to a <code>DataBuffer</code>. By using <code>stackalloc</code>, these methods avoid memory allocations, making them highly efficient for network messaging. The returned <code>DataBuffer</code> must be disposed or used within a <code>using</code> statement to ensure proper memory management.</p> <p>Returns</p> <ul> <li><code>DataBuffer</code>: The network message buffer containing the written values.</li> </ul> FastWrite (T1 t1)FastWrite (T1 t1, T2 t2)FastWrite (T1 t1, T2 t2, T3 t3)FastWrite (T1 t1, T2 t2, T3 t3, T4 t4)FastWrite (T1 t1, T2 t2, T3 t3, T4 t4, T5 t5)FastWrite (T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) <p>Writes a single unmanaged value to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. Example Example C#<pre><code>using (var message = NetworkManager.FastWrite(42))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes two unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. Example Example C#<pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes three unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. Example Example C#<pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A'))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes four unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. <code>t4</code> <code>T4</code> The fourth value to write to the buffer. Example Example C#<pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A', true))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes five unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. <code>t4</code> <code>T4</code> The fourth value to write to the buffer. <code>t5</code> <code>T5</code> The fifth value to write to the buffer. Example Example C#<pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A', true, 99))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Writes six unmanaged values to the buffer.</p> Parameter Type Description <code>t1</code> <code>T1</code> The first value to write to the buffer. <code>t2</code> <code>T2</code> The second value to write to the buffer. <code>t3</code> <code>T3</code> The third value to write to the buffer. <code>t4</code> <code>T4</code> The fourth value to write to the buffer. <code>t5</code> <code>T5</code> The fifth value to write to the buffer. <code>t6</code> <code>T6</code> The sixth value to write to the buffer. Example Example C#<pre><code>using (var message = NetworkManager.FastWrite(42, 3.14f, 'A', true, 99, 2.718))\n{\n    // Use the message buffer\n}\n</code></pre> <p>Remarks</p> <ul> <li>Disposal: The caller must ensure that the returned <code>DataBuffer</code> is disposed or used within a <code>using</code> statement to prevent memory leaks.</li> <li>Performance: By using <code>stackalloc</code>, this method avoids heap allocations, offering high performance for network messaging.</li> <li>Generic Constraints: Only unmanaged types are allowed, ensuring compatibility with <code>DataBuffer</code> for efficient serialization.</li> </ul>"},{"location":"api_reference/#frombinary","title":"FromBinary","text":"<p>Deserializes an object from binary format using <code>MemoryPackSerializer</code>.</p> <ul> <li>Signature: <code>public static T FromBinary&lt;T&gt;(byte[] data, MemoryPackSerializerOptions settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to deserialize. <p>Parameters</p> Parameter Type Description <code>data</code> <code>byte[]</code> The byte array containing the binary data to deserialize. <code>settings</code> <code>MemoryPackSerializerOptions</code> Optional settings for deserialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>FromBinary</code> method deserializes an object of type <code>T</code> from a binary byte array using the <code>MemoryPackSerializer</code>. It allows specifying optional deserialization settings through <code>MemoryPackSerializerOptions</code>. If no settings are provided, the method uses the default settings defined in <code>BufferWriterExtensions.DefaultMemoryPackSettings</code>.</p> <p>Returns</p> <ul> <li><code>T</code>: The deserialized object of type <code>T</code>.</li> </ul> Example C#<pre><code>// Example of deserializing an object from binary data\nbyte[] binaryData = GetBinaryData(); // Assume this retrieves a valid byte array\nMyObject deserializedObject = NetworkManager.FromBinary&lt;MyObject&gt;(binaryData);\n</code></pre>"},{"location":"api_reference/#tobinary","title":"ToBinary","text":"<p>Converts an object to binary format using <code>MemoryPackSerializer</code>.</p> <ul> <li>Signature: <code>public static byte[] ToBinary&lt;T&gt;(T obj, MemoryPackSerializerOptions settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to serialize. <p>Parameters</p> Parameter Type Description <code>obj</code> <code>T</code> The object to be converted to binary format. <code>settings</code> <code>MemoryPackSerializerOptions</code> Optional settings for serialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>ToBinary</code> method serializes an object of type <code>T</code> into a binary byte array using <code>MemoryPackSerializer</code>. It allows specifying optional serialization settings via <code>MemoryPackSerializerOptions</code>. If no settings are provided, the method uses the default settings from <code>BufferWriterExtensions.DefaultMemoryPackSettings</code>.</p> <p>Returns</p> <ul> <li><code>byte[]</code>: A byte array representing the binary serialization of the object.</li> </ul> Example C#<pre><code>// Example of serializing an object to binary data\nMyObject obj = new MyObject();\nbyte[] binaryData = NetworkManager.ToBinary(obj);\n\n// Example with custom settings\nMemoryPackSerializerOptions customSettings = new MemoryPackSerializerOptions\n{\n    // Custom settings configuration\n};\nbyte[] binaryData = NetworkManager.ToBinary(obj, customSettings);\n</code></pre>"},{"location":"api_reference/#fromjson","title":"FromJson","text":"<p>Deserializes an object from JSON format.</p> <ul> <li>Signature: <code>public static T FromJson&lt;T&gt;(string json, JsonSerializerSettings settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to deserialize. <p>Parameters</p> Parameter Type Description <code>json</code> <code>string</code> The JSON string to deserialize. <code>settings</code> <code>JsonSerializerSettings</code> Optional settings for JSON deserialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>FromJson</code> method deserializes an object of type <code>T</code> from a JSON string. This method allows specifying optional deserialization settings via <code>JsonSerializerSettings</code>. If no settings are provided, the default settings from <code>BufferWriterExtensions.DefaultJsonSettings</code> are used.</p> <p>Returns</p> <ul> <li><code>T</code>: The deserialized object of type <code>T</code>.</li> </ul> Example C#<pre><code>// Example of deserializing an object from a JSON string\nstring jsonString = \"{\\\"Name\\\":\\\"John\\\", \\\"Age\\\":30}\";\nPerson person = NetworkManager.FromJson&lt;Person&gt;(jsonString);\n\n// Example with custom settings\nJsonSerializerSettings customSettings = new JsonSerializerSettings\n{\n    Formatting = Formatting.Indented\n};\nPerson person = NetworkManager.FromJson&lt;Person&gt;(jsonString, customSettings);\n</code></pre>"},{"location":"api_reference/#tojson","title":"ToJson","text":"<p>Converts an object to JSON format.</p> <ul> <li>Signature: <code>public static string ToJson&lt;T&gt;(T obj, JsonSerializerSettings settings = null)</code></li> </ul> <p>Type Parameters</p> Type Parameter Description <code>T</code> The type of the object to serialize. <p>Parameters</p> Parameter Type Description <code>obj</code> <code>T</code> The object to be converted to JSON format. <code>settings</code> <code>JsonSerializerSettings</code> Optional settings for JSON serialization (default is <code>null</code>). If <code>null</code>, default settings are used. <p>Description</p> <p>The <code>ToJson</code> method serializes an object of type <code>T</code> into a JSON string using <code>JsonConvert</code>. This method allows for optional JSON serialization settings via <code>JsonSerializerSettings</code>. If no settings are specified, it uses the default settings defined in <code>BufferWriterExtensions.DefaultJsonSettings</code>.</p> <p>Returns</p> <ul> <li><code>string</code>: A JSON string representation of the serialized object.</li> </ul> Example C#<pre><code>// Example of serializing an object to JSON format\nPerson person = new Person { Name = \"John\", Age = 30 };\nstring jsonString = NetworkManager.ToJson(person);\n\n// Example with custom settings\nJsonSerializerSettings customSettings = new JsonSerializerSettings\n{\n    Formatting = Formatting.Indented\n};\nstring jsonString = NetworkManager.ToJson(person, customSettings);\n</code></pre>"},{"location":"api_reference/#initializemodule","title":"InitializeModule","text":"<p>Initializes a specified network module based on the provided <code>Module</code> type.</p> <ul> <li>Signature: <code>public static void InitializeModule(Module module)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>module</code> <code>Module</code> The type of module to initialize. <p>Description</p> <p>The <code>InitializeModule</code> method initializes a network module based on the specified <code>Module</code> type. This includes setting up components for ticking, network time, console, connections, and matchmaking as required. The method ensures that the initialization occurs on the main thread and applies appropriate configurations based on each module\u2019s unique requirements.</p> <p>Module Types</p> <ul> <li><code>TickSystem</code>: Initializes a network tick system if one doesn\u2019t already exist. Sets up the tick rate using <code>Manager.m_TickRate</code>.</li> <li><code>NtpClock</code>: Initializes an SNTP clock based on <code>NetworkClock</code> settings, configuring interval and tick timing.</li> <li><code>Console</code>: Initializes a <code>NetworkConsole</code> instance.</li> <li><code>Connection</code>: Sets up the client and server transporters, checks for a transporter component, and configures network connection. Includes logic for auto-starting the server and client based on specific address conditions and the current build configuration.</li> <li><code>Matchmaking</code>: Initializes the network matchmaking module.</li> </ul> Example C#<pre><code>// Example of initializing the TickSystem module\nNetworkManager.InitializeModule(Module.TickSystem);\n\n// Example of initializing the Connection module\ntry\n{\n    NetworkManager.InitializeModule(Module.Connection);\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre> <p>Remarks</p> <ul> <li>Thread Safety: The method enforces that initialization occurs on the main thread to prevent multithreading issues.</li> <li>Connection Transporter: Throws an Exception if no transporter is found on NetworkManager when initializing the Connection module.</li> <li>Auto-Start Logic: In the Connection module, auto-start behavior is configured based on the client\u2019s address. The server will only auto-start if the address is recognized as localhost or a public IP address.</li> <li>Build Configuration: Auto-starting behavior may vary based on build configuration. For instance, in OMNI_RELEASE builds, both server and client auto-start are enabled by default.</li> </ul>"},{"location":"api_reference/#loadscene-loadsceneasync","title":"LoadScene / LoadSceneAsync","text":"<p>Loads a scene by name or index, with options for synchronous or asynchronous loading. These methods also provide optional parameters to destroy the current scene before loading a new one.</p> <ul> <li>Signature:</li> <li><code>public static void LoadScene(string sceneName, LoadSceneMode mode = LoadSceneMode.Single)</code></li> <li><code>public static AsyncOperation LoadSceneAsync(string sceneName, LoadSceneMode mode = LoadSceneMode.Single)</code></li> <li><code>public static void LoadScene(int index, LoadSceneMode mode = LoadSceneMode.Single)</code></li> <li><code>public static AsyncOperation LoadSceneAsync(int index, LoadSceneMode mode = LoadSceneMode.Single)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to load. <code>index</code> <code>int</code> The build index of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Specifies whether to load the scene in <code>Single</code> or <code>Additive</code> mode (default is <code>Single</code>). <p>Description</p> <p>Each overload of <code>LoadScene</code> and <code>LoadSceneAsync</code> allows loading scenes either by name or by build index, with the option to specify loading in single or additive mode. The methods also include a call to <code>DestroyScene</code> to clear the current scene before loading the new one, supporting smooth transitions and memory management.</p> <p>Overloads</p> LoadScene (string sceneName, LoadSceneMode mode = LoadSceneMode.Single)LoadSceneAsync (string sceneName, LoadSceneMode mode = LoadSceneMode.Single)LoadScene (int index, LoadSceneMode mode = LoadSceneMode.Single)LoadSceneAsync (int index, LoadSceneMode mode = LoadSceneMode.Single) <p>Loads a scene by its name in synchronous mode.</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example Example C#<pre><code>// Load a scene by name\nNetworkManager.LoadScene(\"MainScene\");\n</code></pre> <p>Loads a scene by its name in asynchronous mode, returning an <code>AsyncOperation</code>.</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example Example C#<pre><code>// Load a scene asynchronously by name\nAsyncOperation loadOperation = NetworkManager.LoadSceneAsync(\"MainScene\");\n</code></pre> <p>Loads a scene by its build index in synchronous mode.</p> Parameter Type Description <code>index</code> <code>int</code> The build index of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example Example C#<pre><code>// Load a scene by build index\nNetworkManager.LoadScene(1);\n</code></pre> <p>Loads a scene by its build index in asynchronous mode, returning an <code>AsyncOperation</code>.</p> Parameter Type Description <code>index</code> <code>int</code> The build index of the scene to load. <code>mode</code> <code>LoadSceneMode</code> Load mode (Single or Additive). Defaults to Single. Example Example C#<pre><code>// Load a scene asynchronously by build index\nAsyncOperation loadOperation = NetworkManager.LoadSceneAsync(1);\n</code></pre> <p>Remarks</p> <ul> <li>DestroyScene: Each method calls <code>DestroyScene</code> before loading to remove the current scene and free resources.</li> <li>LoadSceneMode: Allows loading in <code>Single</code> mode, which replaces the current scene, or <code>Additive</code> mode, which loads the new scene on top of the existing one.</li> <li>AsyncOperation: In asynchronous methods, an <code>AsyncOperation</code> is returned, which can be used to track the progress of scene loading.</li> <li>Error Handling: Ensure the specified scene name or index is valid to avoid loading errors.</li> </ul>"},{"location":"api_reference/#unloadsceneasync","title":"UnloadSceneAsync","text":"<p>Asynchronously unloads a scene by its name or index with options for unloading behavior.</p> <ul> <li>Signature:</li> <li><code>public static AsyncOperation UnloadSceneAsync(string sceneName, UnloadSceneOptions options = UnloadSceneOptions.None)</code></li> <li><code>public static AsyncOperation UnloadSceneAsync(int index, bool useBuildIndex = false, UnloadSceneOptions options = UnloadSceneOptions.None)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to unload. <code>index</code> <code>int</code> The index of the scene to unload, which can refer to the build index or scene load order. <code>useBuildIndex</code> <code>bool</code> Indicates if the <code>index</code> parameter should be interpreted as the build index (default is <code>false</code>). <code>options</code> <code>UnloadSceneOptions</code> Options for unloading the scene (default is <code>None</code>). <p>Description</p> <p>The <code>UnloadSceneAsync</code> method provides asynchronous scene unloading capabilities. You can specify the scene to unload either by its name or index, with the option to interpret the index as the build index. Each method first calls <code>DestroyScene</code> to handle any necessary scene cleanup before initiating the asynchronous unloading operation using <code>SceneManager.UnloadSceneAsync</code>.</p> <p>Overloads</p> UnloadSceneAsync (string sceneName, UnloadSceneOptions options = UnloadSceneOptions.None)UnloadSceneAsync (int index, bool useBuildIndex = false, UnloadSceneOptions options = UnloadSceneOptions.None) <p>Unloads a scene asynchronously by its name.</p> Parameter Type Description <code>sceneName</code> <code>string</code> The name of the scene to unload. <code>options</code> <code>UnloadSceneOptions</code> Options for unloading the scene (default is <code>None</code>). Example Example C#<pre><code>// Unload a scene asynchronously by name\nAsyncOperation unloadOperation = NetworkManager.UnloadSceneAsync(\"MainScene\");\n</code></pre> <p>Unloads a scene asynchronously by its index, with the option to interpret the index as the build index.</p> Parameter Type Description <code>index</code> <code>int</code> The index of the scene to unload. <code>useBuildIndex</code> <code>bool</code> Whether the index refers to the build index (default is <code>false</code>). <code>options</code> <code>UnloadSceneOptions</code> Options for unloading the scene (default is <code>None</code>). Example Example C#<pre><code>// Unload a scene asynchronously by build index\nAsyncOperation unloadOperation = NetworkManager.UnloadSceneAsync(1, useBuildIndex: true);\n</code></pre> <p>Remarks</p> <ul> <li>DestroyScene: Each method calls <code>DestroyScene</code> before unloading to handle any necessary cleanup operations and prevent memory leaks.</li> <li>UnloadSceneOptions: Options can be provided for customizing the unloading process, such as removing dependencies.</li> <li>AsyncOperation: Returns an <code>AsyncOperation</code> that can be used to track the progress of the unloading process.</li> <li>Usage: Ideal for offloading scenes when they are no longer needed, helping to manage memory and resources efficiently.</li> </ul>"},{"location":"api_reference/#spawnonclient","title":"SpawnOnClient","text":"<p>Instantiates a network identity on the client.</p> <ul> <li>Signature: <code>public static NetworkIdentity SpawnOnClient(NetworkIdentity prefab, int peerId, int identityId)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peerId</code> <code>int</code> The ID of the peer who owns the instantiated object. <code>identityId</code> <code>int</code> The ID of the instantiated object. <p>Description</p> <p>The <code>SpawnOnClient</code> method instantiates a <code>NetworkIdentity</code> object on the client. It checks if the instantiated object is owned by the local player and updates the <code>LocalPlayer</code> reference if appropriate. After instantiation, it notifies the server that this identity has been spawned on the client side.</p> <p>Returns</p> <ul> <li><code>NetworkIdentity</code>: The instantiated network identity object.</li> </ul> Example C#<pre><code>// Example of spawning a network identity on the client\nNetworkIdentity playerPrefab = GetPlayerPrefab(); // Assume this retrieves a valid NetworkIdentity prefab\nNetworkIdentity newPlayer = NetworkManager.SpawnOnClient(playerPrefab, peerId: 1, identityId: 1001);\nDebug.Log(\"Player instantiated on client: \" + newPlayer.name);\n</code></pre>"},{"location":"api_reference/#spawnonserver","title":"SpawnOnServer","text":"<p>Instantiates a network identity on the server for a specific peer or with a specified ID.</p> <ul> <li>Signature:</li> <li><code>public static NetworkIdentity SpawnOnServer(NetworkIdentity prefab, NetworkPeer peer)</code></li> <li><code>public static NetworkIdentity SpawnOnServer(NetworkIdentity prefab, NetworkPeer peer, int identityId)</code></li> <li><code>public static NetworkIdentity SpawnOnServer(NetworkIdentity prefab, int peerId, int identityId = 0)</code></li> </ul> <p>Parameters</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peer</code> <code>NetworkPeer</code> The peer who will receive the instantiated object. <code>peerId</code> <code>int</code> The ID of the peer who will receive the instantiated object (for overloads without <code>peer</code>). <code>identityId</code> <code>int</code> The ID of the instantiated object. If not provided, a unique ID will be dynamically generated. <p>Description</p> <p>The <code>SpawnOnServer</code> method provides multiple overloads to instantiate a <code>NetworkIdentity</code> object on the server. The instantiation can be performed for a specific peer, identified either by a <code>NetworkPeer</code> object or a <code>peerId</code>. If an <code>identityId</code> is not provided, a unique ID is generated dynamically.</p> <p>Overloads</p> SpawnOnServer (NetworkIdentity prefab, NetworkPeer peer)SpawnOnServer (NetworkIdentity prefab, NetworkPeer peer, int identityId)SpawnOnServer (NetworkIdentity prefab, int peerId, int identityId = 0) <p>Instantiates a network identity on the server for a specific peer.</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peer</code> <code>NetworkPeer</code> The peer who will receive the object. Example Example C#<pre><code>// Example of spawning a network identity on the server for a specific peer\nNetworkIdentity playerPrefab = GetPlayerPrefab();\nNetworkIdentity newPlayer = NetworkManager.SpawnOnServer(playerPrefab, somePeer);\n</code></pre> <p>Instantiates a network identity on the server for a specific peer with a specified identity ID.</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peer</code> <code>NetworkPeer</code> The peer who will receive the object. <code>identityId</code> <code>int</code> The ID of the instantiated object. Example Example C#<pre><code>// Example of spawning a network identity with a specific ID on the server for a peer\nNetworkIdentity newPlayer = NetworkManager.SpawnOnServer(playerPrefab, somePeer, 1001);\n</code></pre> <p>Instantiates a network identity on the server using a peer ID and an optional identity ID. If <code>identityId</code> is not provided, a unique ID is generated dynamically.</p> Parameter Type Description <code>prefab</code> <code>NetworkIdentity</code> The prefab to instantiate. <code>peerId</code> <code>int</code> The ID of the peer who will receive the object. <code>identityId</code> <code>int</code> The ID of the instantiated object, or <code>0</code> for a unique ID. Example Example C#<pre><code>// Example of spawning a network identity on the server by peer ID, with auto-generated ID\nNetworkIdentity newPlayer = NetworkManager.SpawnOnServer(playerPrefab, peerId: 1);\n</code></pre> <p>Remarks</p> <ul> <li>Dynamic ID Generation: If <code>identityId</code> is <code>0</code>, the method generates a unique ID for the instantiated object using <code>NetworkHelper.GenerateDynamicUniqueId()</code>.</li> <li>Peer Association: The instantiated object is associated with the specified peer, allowing for ownership and network synchronization based on peer ID.</li> <li>Usage: Suitable for spawning networked objects on the server side, with flexibility for assigning specific identity IDs or generating them dynamically.</li> </ul>"},{"location":"api_reference/#sendmessageclient","title":"SendMessage(Client)","text":"<p>Sends a message from the client to the server, with options for specifying message content, delivery mode, and sequence channel.</p> <ul> <li>Signature:</li> <li><code>public static void SendMessage(byte msgId, SyncOptions options)</code></li> <li><code>public static void SendMessage(byte msgId, DataBuffer buffer = null, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>SendMessage</code> method allows the client to send a message to the server, either by using <code>SyncOptions</code> or by specifying detailed parameters such as <code>DataBuffer</code>, <code>DeliveryMode</code>, and <code>SequenceChannel</code>. This function provides flexible control over how messages are delivered, including options for reliable, ordered delivery and custom sequencing to maintain message order.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization, including buffer, delivery mode, and channel. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>deliveryMode</code> <code>DeliveryMode</code> Specifies the delivery mode, such as <code>ReliableOrdered</code> or <code>Unreliable</code> (default is <code>ReliableOrdered</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing, to control message order consistency across channels (default is <code>0</code>). <p>Overloads</p> SendMessage (byte msgId, SyncOptions options)SendMessage (byte msgId, DataBuffer buffer = null, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, byte sequenceChannel = 0) <p>Sends a message to the server using <code>SyncOptions</code> to define the buffer, delivery mode, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example Example C#<pre><code>// Example of sending a message using SyncOptions\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    DeliveryMode = DeliveryMode.Unreliable,\n    SequenceChannel = 0\n};\nNetworkManager.Client.SendMessage(1, syncOptions);\n</code></pre> <p>Sends a message to the server with detailed parameters for buffer, delivery mode, and sequencing.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example Example C#<pre><code>// Example of sending a message with detailed parameters\nNetworkManager.Client.SendMessage(\n    1,\n    buffer: myDataBuffer,\n    deliveryMode: DeliveryMode.Unreliable,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Client-to-Server Communication: Allows the client to send messages to the server, ideal for client-initiated requests or updates.</li> <li>Flexible Delivery Options: Supports both reliable and unreliable delivery modes, as well as ordered or unordered options, depending on the use case.</li> <li>Sequencing Control: Use the <code>sequenceChannel</code> to maintain message order across multiple channels, ensuring consistency in message flow.</li> <li>Usage: Commonly used for sending custom data, requests, or status updates from the client to the server.</li> </ul>"},{"location":"api_reference/#sendmessageserver","title":"SendMessage(Server)","text":"<p>Sends a message from the server to a client or from a client to other networked peers on the server side, with optional configurable options for target, delivery mode, grouping, and sequencing.</p> <ul> <li>Signature:</li> <li><code>public static void SendMessage(byte msgId, NetworkPeer peer, SyncOptions options)</code></li> <li><code>public static void SendMessage(byte msgId, NetworkPeer peer, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0)</code></li> </ul> <p>Description</p> <p>The <code>SendMessage</code> method provides multiple overloads to send a message through the network with flexible settings for various parameters. The method allows specifying the message ID, target peer, and delivery options like delivery mode, group ID, and sequence channel. This enables fine-grained control over how messages are delivered, such as targeting specific peers, ensuring message ordering, and managing data cache. <code>SendMessage</code> is typically used to send data from the server to clients or between clients.</p> <p>Parameters</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>peer</code> <code>NetworkPeer</code> The peer to send the message to. <code>options</code> <code>SyncOptions</code> A set of options for message synchronization (used in the first overload). <code>buffer</code> <code>DataBuffer</code> Optional data buffer to send. <code>target</code> <code>Target</code> Specifies the target for the message (default is <code>All</code>). <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code> (default), <code>Unreliable</code>, etc. <code>groupId</code> <code>int</code> ID for grouping related messages together (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Cache option for the data being sent (default is <code>DataCache.None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing to manage order consistency across channels (default is <code>0</code>). <p>Overloads</p> SendMessage (byte msgId, NetworkPeer peer, SyncOptions options)SendMessage (byte msgId, NetworkPeer peer, DataBuffer buffer = null, Target target = Target.All, DeliveryMode deliveryMode = DeliveryMode.ReliableOrdered, int groupId = 0, DataCache dataCache = default, byte sequenceChannel = 0) <p>Sends a message using a <code>SyncOptions</code> instance to specify buffer, target, delivery mode, group ID, data cache, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>peer</code> <code>NetworkPeer</code> The peer to send the message to. <code>options</code> <code>SyncOptions</code> Configuration options for synchronization. Example Example C#<pre><code>// Example of sending a message with SyncOptions(optional)\nSyncOptions syncOptions = new SyncOptions(myDataBuffer)\n{\n    Target = Target.All,\n    DeliveryMode = DeliveryMode.Unreliable,\n    GroupId = 0,\n    DataCache = DataCache.None,\n    SequenceChannel = 0\n};\nNetworkManager.Server.SendMessage(1, clientPeer, syncOptions);\n</code></pre> <p>Sends a message with detailed parameters for target, delivery mode, grouping, and sequence channel.</p> Parameter Type Description <code>msgId</code> <code>byte</code> The ID of the message to send. <code>peer</code> <code>NetworkPeer</code> The peer to send the message to. <code>buffer</code> <code>DataBuffer</code> Optional data buffer containing the message content. <code>target</code> <code>Target</code> The target for the message, such as <code>All</code>. <code>deliveryMode</code> <code>DeliveryMode</code> Defines the delivery mode, such as <code>ReliableOrdered</code>. <code>groupId</code> <code>int</code> ID for grouping related messages (default is <code>0</code>). <code>dataCache</code> <code>DataCache</code> Specifies how the message data is cached (default is <code>None</code>). <code>sequenceChannel</code> <code>byte</code> Channel for message sequencing (default is <code>0</code>). Example Example C#<pre><code>// Example of sending a message with detailed parameters(optional)\nNetworkManager.Server.SendMessage(\n    1,\n    clientPeer,\n    buffer: myDataBuffer,\n    target: Target.All,\n    deliveryMode: DeliveryMode.Unreliable,\n    groupId: 0,\n    dataCache: DataCache.None,\n    sequenceChannel: 0\n);\n</code></pre> <p>Remarks</p> <ul> <li>Targeting: Allows flexible message targeting, such as sending to all peers, server-only, or specific groups.</li> <li>Delivery Mode: Supports reliable and ordered delivery, or unreliable options for lightweight</li> </ul>"},{"location":"api_reference/#properties","title":"Properties","text":""},{"location":"api_reference/#receivedbandwidth","title":"ReceivedBandwidth","text":"<p>Gets the <code>BandwidthMonitor</code> for monitoring the server's or client incoming bandwidth.</p> <ul> <li>Signature: <code>public static BandwidthMonitor ReceivedBandwidth =&gt; Connection.Server.ReceivedBandwidth</code></li> </ul> <p>Description</p> <p>The <code>ReceivedBandwidth</code> property provides access to the <code>BandwidthMonitor</code> instance that tracks the server\u2019s or client incoming bandwidth usage. This monitor measures the rate of data being received by the server from clients and vice versa, allowing developers to analyze and optimize network performance.</p> <p>Returns</p> <ul> <li><code>BandwidthMonitor</code>: An instance that tracks and measures the server's or client incoming bandwidth usage.</li> </ul> Example C#<pre><code>// Example of monitoring changes in the server's average received bandwidth\nNetworkManager.Server.ReceivedBandwidth.OnAverageChanged += (avg) =&gt;\n{\n    Debug.Log($\"Average received bandwidth: {avg} bytes per second\");\n};\n\n// Client side\nNetworkManager.Client.ReceivedBandwidth.OnAverageChanged += (avg) =&gt;\n{\n    Debug.Log($\"Average received bandwidth: {avg} bytes per second\");\n};\n</code></pre>"},{"location":"api_reference/#sentbandwidth","title":"SentBandwidth","text":"<p>Gets the <code>BandwidthMonitor</code> for monitoring the server's or client outgoing bandwidth.</p> <ul> <li>Signature: <code>public static BandwidthMonitor SentBandwidth =&gt; Connection.Server.SentBandwidth</code></li> </ul> <p>Description</p> <p>The <code>SentBandwidth</code> property provides access to the <code>BandwidthMonitor</code> instance that tracks the server\u2019s or client outgoing bandwidth usage. This monitor measures the rate of data being sent from the server to clients and vice versa, allowing developers to observe and manage network performance.</p> <p>Returns</p> <ul> <li><code>BandwidthMonitor</code>: An instance that tracks and measures the server's or client outgoing bandwidth usage.</li> </ul> Example C#<pre><code>// Example of accessing SentBandwidth\nNetworkManager.Server.SentBandwidth.OnAverageChanged += (avg) =&gt;\n{\n    Debug.Log($\"Average sent bandwidth: {avg} bytes per second\");\n};\n\n// Client side\nNetworkManager.Client.SentBandwidth.OnAverageChanged += (avg) =&gt;\n{\n    Debug.Log($\"Average sent bandwidth: {avg} bytes per second\");\n};\n</code></pre>"},{"location":"api_reference/#serverpeer","title":"ServerPeer","text":"<p>Gets the server peer, which represents the server within the network as a special <code>NetworkPeer</code> instance.</p> <ul> <li>Signature: <code>public static NetworkPeer ServerPeer { get; }</code></li> </ul> <p>Description</p> <p>The <code>ServerPeer</code> property provides a <code>NetworkPeer</code> instance specifically designated to represent the server. This instance can be used to identify the server in network operations, facilitating communication, control, and synchronization between the server and clients.</p> <p>Remarks</p> <ul> <li>Server Representation: <code>ServerPeer</code> acts as a unique identifier for the server in the network, making it distinct from other peers.</li> <li>Usage: Useful for operations where the server needs to be addressed specifically, such as broadcasting messages to all clients or handling server-specific logic.</li> <li>Initialization: The <code>ServerPeer</code> is instantiated with a default IP endpoint (<code>IPAddress.None</code>) and a port of <code>0</code>, signifying that it is used solely for internal identification rather than active communication.</li> </ul> Example C#<pre><code>// Example of using ServerPeer to check if a peer is the server\nif (NetworkManager.Server.ServerPeer.Equals(somePeer))\n{\n    Debug.Log(\"This peer is the server.\");\n}\n\n// Example of using ServerPeer for a server-specific operation\nNetworkPeer serverPeer = NetworkManager.Server.ServerPeer;\nDebug.Log(\"Server peer address: \" + serverPeer.EndPoint);\n</code></pre> <p>Remarks</p> <p>Client-Side: When <code>NetworkManager.Client.ServerPeer</code> is used, it represents the server peer on the client side, exclusively for encryption keys.</p>"},{"location":"api_reference/#peers","title":"Peers","text":"<p>A dictionary that maps peer IDs to <code>NetworkPeer</code> instances, providing access to all connected peers by their unique IDs.</p> <ul> <li>Signature: <code>public static Dictionary&lt;int, NetworkPeer&gt; Peers =&gt; PeersById</code></li> </ul> <p>Description</p> <p>The <code>Peers</code> property provides a dictionary of all active <code>NetworkPeer</code> instances, keyed by their unique integer IDs. This dictionary allows efficient management and retrieval of network peers, making it easy to access specific clients or other networked entities by their ID.</p> <p>Returns</p> <ul> <li><code>Dictionary&lt;int, NetworkPeer&gt;</code>: A dictionary containing all active <code>NetworkPeer</code> instances, indexed by peer IDs.</li> </ul> Example C#<pre><code>// Example of iterating over all connected peers on the server\nforeach (var kvp in NetworkManager.Server.Peers)\n{\n    int peerId = kvp.Key;\n    NetworkPeer peer = kvp.Value;\n    Debug.Log($\"Peer ID: {peerId}\");\n}\n\n// Example of checking if a specific peer ID exists\nint targetPeerId = 42;\nif (NetworkManager.Server.Peers.ContainsKey(targetPeerId))\n{\n    NetworkPeer peer = NetworkManager.Peers[targetPeerId];\n    Debug.Log($\"Found peer with ID {targetPeerId}\");\n}\nelse\n{\n    Debug.Log($\"No peer found with ID {targetPeerId}\");\n}\n\n// Client side example\nforeach (var kvp in NetworkManager.Client.Peers)\n{\n    int peerId = kvp.Key;\n    NetworkPeer peer = kvp.Value;\n    Debug.Log($\"Peer ID: {peerId}\");\n}\n</code></pre>"},{"location":"api_reference/#identities","title":"Identities","text":"<p>A dictionary that stores all <code>NetworkIdentity</code> instances, mapped by their unique identity IDs.</p> <ul> <li>Signature: <code>public static Dictionary&lt;int, NetworkIdentity&gt; Identities { get; }</code></li> </ul> <p>Description</p> <p>The <code>Identities</code> property provides access to a dictionary containing all <code>NetworkIdentity</code> instances, where each entry is keyed by a unique integer ID (<code>identityId</code>). This dictionary allows efficient retrieval and management of networked identities, enabling easy access to any networked object within the application.</p> <p>Returns</p> <ul> <li><code>Dictionary&lt;int, NetworkIdentity&gt;</code>: A dictionary of <code>NetworkIdentity</code> instances, keyed by unique identity IDs.</li> </ul> Example C#<pre><code>// Example of iterating over all NetworkIdentity instances on the server\nforeach (var kvp in NetworkManager.Server.Identities)\n{\n    int id = kvp.Key;\n    NetworkIdentity identity = kvp.Value;\n    Debug.Log($\"NetworkIdentity ID: {id}, Name: {identity.name}\");\n}\n\n// Example of checking if a specific ID exists\nint identityId = 101;\nif (NetworkManager.Server.Identities.ContainsKey(identityId))\n{\n    NetworkIdentity identity = NetworkManager.Identities[identityId];\n    Debug.Log($\"Found NetworkIdentity with ID {identityId}: {identity.name}\");\n}\nelse\n{\n    Debug.Log($\"No NetworkIdentity found with ID {identityId}\");\n}\n\n/////////////////////// Client side\n// Example of iterating over all NetworkIdentity instances\nforeach (var kvp in NetworkManager.Client.Identities)\n{\n    int id = kvp.Key;\n    NetworkIdentity identity = kvp.Value;\n    Debug.Log($\"NetworkIdentity ID: {id}, Name: {identity.name}\");\n}\n\n// Example of checking if a specific ID exists\nif (NetworkManager.Client.Identities.ContainsKey(identityId))\n{\n    NetworkIdentity identity = NetworkManager.Identities[identityId];\n    Debug.Log($\"Found NetworkIdentity with ID {identityId}: {identity.name}\");\n}\n</code></pre>"},{"location":"api_reference/#clientlistenport","title":"ClientListenPort","text":"<p>Gets the port on which the client listens for incoming connections.</p> <ul> <li>Signature: <code>public static int ClientListenPort</code></li> </ul> <p>Description</p> <p>The <code>ClientListenPort</code> property provides access to the client\u2019s listening port, as configured in <code>Manager.m_ClientListenPort</code>. This port is used for network communications on the client side, enabling it to receive messages from the server.</p> <p>Returns</p> <ul> <li><code>int</code>: The port number on which the client listens.</li> </ul> Example C#<pre><code>// Example of retrieving the client's listening port\nint clientPort = NetworkManager.ClientListenPort;\nDebug.Log(\"Client listening on port: \" + clientPort);\n</code></pre>"},{"location":"api_reference/#serverlistenport","title":"ServerListenPort","text":"<p>Gets the port on which the server listens for incoming connections.</p> <ul> <li>Signature: <code>public static int ServerListenPort</code></li> </ul> <p>Description</p> <p>The <code>ServerListenPort</code> property provides access to the server\u2019s listening port, as configured in <code>Manager.m_ServerListenPort</code>. This port is used for network communications on the server side, enabling it to accept incoming connections from clients.</p> <p>Returns</p> <ul> <li><code>int</code>: The port number on which the server listens.</li> </ul> Example C#<pre><code>// Example of retrieving the server's listening port\nint serverPort = NetworkManager.ServerListenPort;\nDebug.Log(\"Server listening on port: \" + serverPort);\n</code></pre>"},{"location":"api_reference/#connectport","title":"ConnectPort","text":"<p>Gets the port on which the client connects to the server.</p> <ul> <li>Signature: <code>public static int ConnectPort</code></li> </ul> <p>Description</p> <p>The <code>ConnectPort</code> property provides access to the port number that the client uses to connect to the server, as configured in <code>Manager.m_ConnectPort</code>. This port is the endpoint on the server to which the client establishes a connection.</p> <p>Returns</p> <ul> <li><code>int</code>: The port number that the client uses to connect to the server.</li> </ul> Example C#<pre><code>// Example of retrieving the server's connection port\nint serverConnectionPort = NetworkManager.ConnectPort;\nDebug.Log(\"Client will connect to server on port: \" + serverConnectionPort);\n</code></pre>"},{"location":"api_reference/#connectaddress","title":"ConnectAddress","text":"<p>Gets the IP address or hostname that the client uses to connect to the server.</p> <ul> <li>Signature: <code>public static string ConnectAddress</code></li> </ul> <p>Description</p> <p>The <code>ConnectAddress</code> property provides access to the IP address or hostname of the server that the client connects to, as configured in <code>Manager.m_ConnectAddress</code>. This address is used as the endpoint for the client\u2019s connection to the server.</p> <p>Returns</p> <ul> <li><code>string</code>: The IP address or hostname of the server that the client will connect to.</li> </ul> Example C#<pre><code>// Example of retrieving the server's connection address\nstring serverAddress = NetworkManager.ConnectAddress;\nDebug.Log(\"Client will connect to server at address: \" + serverAddress);\n</code></pre>"},{"location":"api_reference/#framerate","title":"Framerate","text":"<p>Gets the current framerate of the application.</p> <ul> <li>Signature: <code>public static float Framerate { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>Framerate</code> property provides access to the application's current framerate. This value can be used to monitor the performance of the application in real-time, allowing developers to adjust settings or configurations based on performance metrics.</p> <p>Returns</p> <ul> <li><code>float</code>: The current framerate of the application.</li> </ul> Example C#<pre><code>// Example of retrieving the current application framerate\nfloat currentFramerate = NetworkManager.Framerate;\nDebug.Log(\"Current application framerate: \" + currentFramerate + \" FPS\");\n</code></pre>"},{"location":"api_reference/#cputimems","title":"CpuTimeMs","text":"<p>Gets the CPU time in milliseconds per frame.</p> <ul> <li>Signature: <code>public static float CpuTimeMs { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>CpuTimeMs</code> property provides access to the CPU time taken per frame, measured in milliseconds. This metric indicates the amount of time the CPU spends processing each frame, which is useful for monitoring and optimizing application performance.</p> <p>Returns</p> <ul> <li><code>float</code>: The CPU time per frame, in milliseconds.</li> </ul> Example C#<pre><code>// Example of retrieving the CPU time per frame in milliseconds\nfloat cpuTimePerFrame = NetworkManager.CpuTimeMs;\nDebug.Log(\"CPU time per frame: \" + cpuTimePerFrame + \" ms\");\n</code></pre>"},{"location":"api_reference/#clocktime","title":"ClockTime","text":"<p>Gets the current clock time in seconds, based on tick timing or elapsed stopwatch time.</p> <ul> <li>Signature: <code>public static double ClockTime</code></li> </ul> <p>Description</p> <p>The <code>ClockTime</code> property provides the current time in seconds, which is independent of the frame rate. The time source depends on the <code>UseTickTiming</code> setting: - Tick Timing: If <code>UseTickTiming</code> is enabled, the time is based on the <code>TickSystem.ElapsedTicks</code>. - Stopwatch: If <code>UseTickTiming</code> is disabled, the time is derived from <code>_stopwatch.Elapsed.TotalSeconds</code>.</p> <p>This setup allows for precise timing control, whether using fixed ticks or continuous stopwatch measurements.</p> <p>Returns</p> <ul> <li><code>double</code>: The current clock time in seconds.</li> </ul> Example C#<pre><code>// Example of retrieving the current clock time\ndouble currentTime = NetworkManager.ClockTime;\nDebug.Log(\"Current clock time: \" + currentTime + \" seconds\");\n</code></pre>"},{"location":"api_reference/#useticktiming","title":"UseTickTiming","text":"<p>Indicates whether the application is using tick-based timing for the <code>ClockTime</code> property.</p> <ul> <li>Signature: <code>public static bool UseTickTiming { get; private set; } = false</code></li> </ul> <p>Description</p> <p>The <code>UseTickTiming</code> property determines whether the application relies on tick-based timing or real-time stopwatch timing for the <code>ClockTime</code> property. When <code>UseTickTiming</code> is set to <code>true</code>, <code>ClockTime</code> is based on <code>TickSystem.ElapsedTicks</code>; otherwise, it uses <code>_stopwatch.Elapsed.TotalSeconds</code>.</p> <p>Returns</p> <ul> <li><code>bool</code>: <code>true</code> if tick-based timing is enabled; <code>false</code> if stopwatch timing is used.</li> </ul> Example C#<pre><code>// Example of checking the timing mode\nif (NetworkManager.UseTickTiming)\n{\n    Debug.Log(\"Using tick-based timing for clock time.\");\n}\nelse\n{\n    Debug.Log(\"Using real-time stopwatch timing for clock time.\");\n}\n</code></pre>"},{"location":"api_reference/#localendpoint","title":"LocalEndPoint","text":"<p>Gets the local network endpoint, represented by an <code>IPEndPoint</code> instance.</p> <ul> <li>Signature: <code>public static IPEndPoint LocalEndPoint { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>LocalEndPoint</code> property provides the IP address and port number of the local peer in the form of an <code>IPEndPoint</code> object. This endpoint represents the local network location, allowing other peers to identify and communicate with the local instance.</p> <p>Returns</p> <ul> <li><code>IPEndPoint</code>: The IP address and port of the local peer.</li> </ul> Example C#<pre><code>// Example of retrieving the local network endpoint\nIPEndPoint localEndpoint = NetworkManager.LocalEndPoint;\nDebug.Log(\"Local IP Address: \" + localEndpoint.Address + \", Port: \" + localEndpoint.Port);\n</code></pre>"},{"location":"api_reference/#isclientactive","title":"IsClientActive","text":"<p>Indicates whether the client is currently active, authenticated, and connected.</p> <ul> <li>Signature: <code>public static bool IsClientActive { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>IsClientActive</code> property returns <code>true</code> if the client is currently active, authenticated, and connected to the network; otherwise, it returns <code>false</code>. This property is used to determine the client\u2019s connection status, allowing the application to handle client-specific logic based on whether the client is connected.</p> <p>Returns</p> <ul> <li><code>bool</code>: <code>true</code> if the client is active, authenticated, and connected; <code>false</code> otherwise.</li> </ul> Example C#<pre><code>// Example of checking if the client is active\nif (NetworkManager.IsClientActive)\n{\n    Debug.Log(\"Client is active and connected to the network.\");\n}\nelse\n{\n    Debug.Log(\"Client is not active.\");\n}\n</code></pre>"},{"location":"api_reference/#isserveractive","title":"IsServerActive","text":"<p>Indicates whether the server is currently active.</p> <ul> <li>Signature: <code>public static bool IsServerActive { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>IsServerActive</code> property returns <code>true</code> if the server is currently active and ready to accept connections; otherwise, it returns <code>false</code>. This property is used to determine the server\u2019s operational status within the network, allowing the application to enable or disable server-dependent features accordingly.</p> <p>Returns</p> <ul> <li><code>bool</code>: <code>true</code> if the server is active; <code>false</code> otherwise.</li> </ul> Example C#<pre><code>// Example of checking if the server is active\nif (NetworkManager.IsServerActive)\n{\n    Debug.Log(\"Server is active and accepting connections.\");\n}\nelse\n{\n    Debug.Log(\"Server is not active.\");\n}\n</code></pre>"},{"location":"api_reference/#sharedpeer","title":"SharedPeer","text":"<p>Gets the shared peer, which is used to secure communication between peers and the server. This peer is useful for handling encryption and authentication in network communications.</p> <ul> <li>Signature: <code>public static NetworkPeer SharedPeer</code></li> </ul> <p>Description</p> <p>The <code>SharedPeer</code> property provides access to the network peer responsible for securing communication between the client and server. Depending on the network state, it returns the appropriate peer for encryption and authentication:   - Client-Server Mode: When both the client and server are active, it returns <code>Server.ServerPeer</code>.   - Client Only: When only the client is active, it returns <code>Client.ServerPeer</code>.   - Server Only: When only the server is active, it defaults to <code>Server.ServerPeer</code>.</p> <p>This flexibility allows the property to provide the correct peer for communication in different network configurations.</p> <p>Returns</p> <ul> <li><code>NetworkPeer</code>: The peer used for secure communication.</li> </ul> Example C#<pre><code>// Example of retrieving the shared peer for secure communication\nNetworkPeer securePeer = NetworkManager.SharedPeer;\nDebug.Log(\"Shared peer for secure communication: \" + securePeer);\n</code></pre>"},{"location":"api_reference/#localpeer","title":"LocalPeer","text":"<p>Gets the local network peer, representing the client in the network.</p> <ul> <li>Signature: <code>public static NetworkPeer LocalPeer</code></li> </ul> <p>Description</p> <p>The <code>LocalPeer</code> property provides access to an instance of the <code>NetworkPeer</code> class that represents the local peer in the network. This property is used to identify and interact with the local peer in networked operations. If the client is not active or authenticated, attempting to access this property throws an exception, ensuring that only active and verified clients can reference <code>LocalPeer</code>.</p> <p>Returns</p> <ul> <li><code>NetworkPeer</code>: The local peer in the network.</li> </ul> Example C#<pre><code>// Example of retrieving the local network peer\ntry\n{\n    NetworkPeer localPeer = NetworkManager.LocalPeer;\n    Debug.Log(\"Local network peer: \" + localPeer);\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre>"},{"location":"api_reference/#mainthreadid","title":"MainThreadId","text":"<p>Gets the ID of the main thread on which the application is running.</p> <ul> <li>Signature: <code>public static int MainThreadId { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>MainThreadId</code> property provides the thread ID of the main thread, allowing the application to distinguish between the main thread and any background or worker threads. This is useful for ensuring that certain operations, particularly those involving UI updates or Unity API calls, are executed on the main thread.</p> <p>Returns</p> <ul> <li><code>int</code>: The ID of the main thread.</li> </ul> Example C#<pre><code>// Example of retrieving the main thread ID\nint mainThreadId = NetworkManager.MainThreadId;\nDebug.Log(\"Main thread ID: \" + mainThreadId);\n</code></pre>"},{"location":"api_reference/#pool","title":"Pool","text":"<p>Gets the pool of <code>DataBuffer</code> instances, used to allocate and deallocate <code>DataBuffer</code> objects efficiently.</p> <ul> <li>Signature: <code>public static IObjectPooling&lt;DataBuffer&gt; Pool { get; private set; }</code></li> </ul> <p>Description</p> <p>The <code>Pool</code> property provides access to an instance of <code>IObjectPooling&lt;DataBuffer&gt;</code>, which manages the allocation and deallocation of <code>DataBuffer</code> instances. By pooling <code>DataBuffer</code> objects, the application reduces memory allocation overhead and enhances performance, especially in networked applications where buffers are frequently used.</p> <p>Returns</p> <ul> <li><code>IObjectPooling&lt;DataBuffer&gt;</code>: The object pool for managing <code>DataBuffer</code> instances.</li> </ul> Example C#<pre><code>// Example 1 of using the DataBuffer pool\nDataBuffer buffer = NetworkManager.Pool.Rent();\nNetworkManager.Pool.Return(buffer); // Return the buffer to the pool\n\n// Example 2(Recommended)\nusing DataBuffer buffer = NetworkManager.Pool.Rent(); // Using return the buffer to the pool\n\n// Example 3\nDataBuffer buffer = NetworkManager.Pool.Rent();\nbuffer.Dispose(); // Return the buffer to the pool\n</code></pre>"},{"location":"api_reference/#console","title":"Console","text":"<p>Gets the <code>NetworkConsole</code> instance, which provides access to the network console module for sending and receiving commands.</p> <ul> <li>Signature: <code>public static NetworkConsole Console</code></li> </ul> <p>Description</p> <p>The <code>Console</code> property provides access to the <code>NetworkConsole</code> instance, which enables sending and receiving commands within the network terminal. This console module is used to execute commands, facilitate remote debugging, and interact with networked systems. Attempting to access this property before initializing the console module will throw an exception, ensuring that <code>InitializeModule(Module.Console)</code> is called prior to usage. Additionally, trying to set the console module more than once will result in an exception.</p> <p>Returns</p> <ul> <li><code>NetworkConsole</code>: The network console instance used for terminal commands.</li> </ul> Example C#<pre><code>try\n{\n    NetworkConsole networkConsole = NetworkManager.Console;\n    networkConsole.OnInput += OnConsoleInput;\n\n    private void OnConsoleInput(string input)\n    {\n        // Handle console input\n    }\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre>"},{"location":"api_reference/#matchmaking","title":"Matchmaking","text":"<p>Gets the <code>NetworkMatchmaking</code> instance, which provides access to the matchmaking module for managing groups and connections.</p> <ul> <li>Signature: <code>public static NetworkMatchmaking Matchmaking</code></li> </ul> <p>Description</p> <p>The <code>Matchmaking</code> property provides access to the <code>NetworkMatchmaking</code> instance, enabling functionality for creating, deleting, and joining groups in a networked environment. This module is essential for managing player groups and facilitating connections between peers for cooperative or competitive play. Attempting to access this property before initializing the matchmaking module will throw an exception, ensuring that <code>InitializeModule(Module.Matchmaking)</code> is called prior to usage. Additionally, trying to set the matchmaking module more than once will result in an exception.</p> <p>Returns</p> <ul> <li><code>NetworkMatchmaking</code>: The matchmaking instance used for group and connection management.</li> </ul> Example C#<pre><code>try\n{\n   var matchmaking = NetworkManager.Matchmaking.Server;\n   NetworkGroup group = matchmaking.AddGroup(\"Team A\");\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre>"},{"location":"api_reference/#sntp","title":"Sntp","text":"<p>Gets the <code>SimpleNtp</code> instance, which provides access to the NTP (Network Time Protocol) clock module for synchronized time and network latency metrics.</p> <ul> <li>Signature: <code>public static SimpleNtp Sntp</code></li> </ul> <p>Description</p> <p>The <code>Sntp</code> property provides access to the <code>SimpleNtp</code> instance, allowing for synchronized time between client and server. This module provides functionality for obtaining synchronized ticks or real time, as well as metrics such as round-trip time (RTT) and ping. Attempting to access this property before initializing the NTP clock module will throw an exception, ensuring that <code>InitializeModule(Module.NtpClock)</code> is called prior to usage. Additionally, attempting to set the NTP clock module more than once will result in an exception.</p> <p>Returns</p> <ul> <li><code>SimpleNtp</code>: The NTP clock instance used for synchronized time and latency measurements.</li> </ul> Example C#<pre><code>// Example of initializing and accessing the NTP clock module\nNetworkManager.InitializeModule(Module.NtpClock); // Initialize the NTP clock module\n\ntry\n{\n    var ntpClock = NetworkManager.Sntp;\n    double synchronizedTime = ntpClock.Client.Time; // Example of retrieving synchronized time\n    print(synchronizedTime);\n}\ncatch (Exception ex)\n{\n    Debug.LogError(ex.Message);\n}\n</code></pre>"},{"location":"api_reference/#ticksystem","title":"TickSystem","text":"<p>Gets the <code>NetworkTickSystem</code> instance, which manages tick-based events that execute at a fixed rate for consistent network timing.</p> <ul> <li>Signature: <code>public static NetworkTickSystem TickSystem</code></li> </ul> <p>Description</p> <p>The <code>TickSystem</code> property provides access to the <code>NetworkTickSystem</code> instance, responsible for executing events at a fixed rate (defined by <code>TickRate</code>) to ensure consistent timing across the network. This system is used to send and process information at a steady frequency, facilitating synchronized interactions between clients and servers. Attempting to access this property before initializing the tick system will throw an exception, ensuring that <code>InitializeModule(Module.TickSystem)</code> is called prior to usage.</p> <p>Returns</p> <ul> <li><code>NetworkTickSystem</code>: The network tick system instance, used for managing tick-based events and timing synchronization.</li> </ul>"},{"location":"api_reference/#events","title":"Events","text":""},{"location":"api_reference/#onsceneloaded","title":"OnSceneLoaded","text":"<p>An event that is triggered when a scene is loaded, providing access to the scene and the load mode.</p> <ul> <li>Signature: <code>public static event Action&lt;Scene, LoadSceneMode&gt; OnSceneLoaded</code></li> </ul> <p>Description</p> <p>The <code>OnSceneLoaded</code> event is invoked whenever a scene is loaded, passing the loaded <code>Scene</code> and the <code>LoadSceneMode</code> as parameters. This event allows for actions to be performed in response to a scene loading, such as initializing objects or updating the UI. Developers can subscribe to <code>OnSceneLoaded</code> to execute custom logic each time a new scene is loaded.</p> <p>Event Parameters</p> Parameter Type Description <code>Scene</code> <code>Scene</code> The scene that has been loaded. <code>LoadSceneMode</code> <code>LoadSceneMode</code> The mode in which the scene was loaded (<code>Single</code> or <code>Additive</code>). Example C#<pre><code>// Example of subscribing to the OnSceneLoaded event\nNetworkManager.OnSceneLoaded += (scene, mode) =&gt;\n{\n    Debug.Log($\"Scene '{scene.name}' loaded with mode: {mode}\");\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnSceneLoaded -= (scene, mode) =&gt;\n{\n    Debug.Log($\"Scene '{scene.name}' loaded with mode: {mode}\");\n};\n</code></pre>"},{"location":"api_reference/#onsceneunloaded","title":"OnSceneUnloaded","text":"<p>An event that is triggered when a scene is unloaded, providing access to the scene that was removed.</p> <ul> <li>Signature: <code>public static event Action&lt;Scene&gt; OnSceneUnloaded</code></li> </ul> <p>Description</p> <p>The <code>OnSceneUnloaded</code> event is invoked whenever a scene is unloaded, passing the <code>Scene</code> that was unloaded as a parameter. This event allows developers to execute custom logic in response to scene unloading, such as cleaning up resources, stopping specific services, or updating the user interface.</p> <p>Event Parameters</p> Parameter Type Description <code>Scene</code> <code>Scene</code> The scene that has been unloaded. Example C#<pre><code>// Example of subscribing to the OnSceneUnloaded event\nNetworkManager.OnSceneUnloaded += (scene) =&gt;\n{\n    Debug.Log($\"Scene '{scene.name}' has been unloaded.\");\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnSceneUnloaded -= (scene) =&gt;\n{\n    Debug.Log($\"Scene '{scene.name}' has been unloaded.\");\n};\n</code></pre>"},{"location":"api_reference/#onbeforesceneload","title":"OnBeforeSceneLoad","text":"<p>An event that is triggered just before a scene is loaded or unloaded, providing the scene and the operation mode (load or unload).</p> <ul> <li>Signature: <code>public static event Action&lt;Scene, SceneOperationMode&gt; OnBeforeSceneLoad</code></li> </ul> <p>Description</p> <p>The <code>OnBeforeSceneLoad</code> event is invoked right before a scene is either loaded or unloaded, passing the target <code>Scene</code> and the <code>SceneOperationMode</code> to indicate the type of operation. This event allows developers to execute preparatory logic, such as pausing certain activities or preparing resources, cleaning up resources, based on whether a scene is about to load or unload.</p> <p>Event Parameters</p> Parameter Type Description <code>Scene</code> <code>Scene</code> The scene that is about to be loaded or unloaded. <code>SceneOperationMode</code> <code>SceneOperationMode</code> Specifies whether the scene operation is a <code>Load</code> or <code>Unload</code>. <p>SceneOperationMode Enum</p> <p>The <code>SceneOperationMode</code> enum defines the operation type for a scene:</p> <ul> <li><code>Load</code>: The scene is about to be loaded.</li> <li><code>Unload</code>: The scene is about to be unloaded.</li> </ul> Example C#<pre><code>// Example of subscribing to the OnBeforeSceneLoad event\nNetworkManager.OnBeforeSceneLoad += (scene, operationMode) =&gt;\n{\n    if (operationMode == SceneOperationMode.Load)\n    {\n        Debug.Log($\"Preparing to load scene '{scene.name}'.\");\n    }\n    else if (operationMode == SceneOperationMode.Unload)\n    {\n        Debug.Log($\"Preparing to unload scene '{scene.name}'.\");\n    }\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnBeforeSceneLoad -= (scene, operationMode) =&gt;\n{\n    Debug.Log($\"Operation {operationMode} for scene '{scene.name}' is about to begin.\");\n};\n</code></pre>"},{"location":"api_reference/#onserverinitialized","title":"OnServerInitialized","text":"<p>An event that is triggered when the server has been successfully initialized.</p> <ul> <li>Signature: <code>public static event Action OnServerInitialized</code></li> </ul> <p>Description</p> <p>The <code>OnServerInitialized</code> event is invoked once the server has been fully initialized and is ready to accept connections. This event allows developers to execute custom logic or set up necessary resources immediately after the server is initialized, such as configuring game settings, starting background tasks.</p> Example C#<pre><code>// Example of subscribing to the OnServerInitialized event\nNetworkManager.OnServerInitialized += () =&gt;\n{\n    Debug.Log(\"Server has been successfully initialized and is ready for connections.\");\n    // Additional server setup code here\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnServerInitialized -= () =&gt;\n{\n    Debug.Log(\"Server initialization event listener removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onserverpeerconnected","title":"OnServerPeerConnected","text":"<p>An event that is triggered when a peer (client) connects to the server, providing access to the connected peer and the connection phase.</p> <ul> <li>Signature: <code>public static event Action&lt;NetworkPeer, Phase&gt; OnServerPeerConnected</code></li> </ul> <p>Description</p> <p>The <code>OnServerPeerConnected</code> event is invoked when a peer connects to the server, with the connection process divided into three phases (<code>Begin</code>, <code>Normal</code>, and <code>End</code>). This event provides developers with the connected <code>NetworkPeer</code> instance and the current <code>Phase</code>, allowing for custom logic to be executed at each stage of the connection.</p> <p>Event Parameters</p> Parameter Type Description <code>NetworkPeer</code> <code>NetworkPeer</code> The peer (client) that has connected to the server. <code>Phase</code> <code>Phase</code> The phase of the connection process (Begin, Normal, End). <p>Phase Enum</p> <p>The <code>Phase</code> enum defines the phases of the peer connection process:</p> <ul> <li><code>Begin</code>: Indicates the start of the connection process.</li> <li><code>Normal</code>: Represents the main connection phase, during which the primary actions are performed.</li> <li><code>End</code>: Marks the completion of the connection process, the peer is connected and authenticated, ready to use.</li> </ul> Example C#<pre><code>// Example of subscribing to the OnServerPeerConnected event\nNetworkManager.OnServerPeerConnected += (peer, phase) =&gt;\n{\n    switch (phase)\n    {\n        case Phase.Begin:\n            Debug.Log($\"Peer {peer.Id} is starting the connection process.\");\n            break;\n        case Phase.Normal:\n            Debug.Log($\"Peer {peer.Id} is now in the main connection phase.\");\n            break;\n        case Phase.End:\n            Debug.Log($\"Peer {peer.Id} has completed the connection process.\");\n            break;\n    }\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnServerPeerConnected -= (peer, phase) =&gt;\n{\n    Debug.Log($\"Listener for peer {peer.Id} connection at phase {phase} removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onserverpeerdisconnected","title":"OnServerPeerDisconnected","text":"<p>An event that is triggered when a peer (client) disconnects from the server, providing access to the disconnected peer and the disconnection phase.</p> <ul> <li>Signature: <code>public static event Action&lt;NetworkPeer, Phase&gt; OnServerPeerDisconnected</code></li> </ul> <p>Description</p> <p>The <code>OnServerPeerDisconnected</code> event is invoked when a peer disconnects from the server, with the disconnection process divided into three phases (<code>Begin</code>, <code>Normal</code>, and <code>End</code>). This event provides the <code>NetworkPeer</code> instance that is disconnecting and the current <code>Phase</code>, allowing for custom logic to be executed at each stage of the disconnection.</p> <p>Event Parameters</p> Parameter Type Description <code>NetworkPeer</code> <code>NetworkPeer</code> The peer (client) that is disconnecting from the server. <code>Phase</code> <code>Phase</code> The phase of the disconnection process (Begin, Normal, End). <p>Phase Enum</p> <p>The <code>Phase</code> enum defines the phases of the peer disconnection process:</p> <ul> <li><code>Begin</code>: Indicates the start of the disconnection process.</li> <li><code>Normal</code>: Represents the main phase of disconnection, during which the primary cleanup or disconnection actions are performed.</li> <li><code>End</code>: Marks the completion of the disconnection process, the peer has fully disconnected from the server and all resources have been cleaned up.</li> </ul> Example C#<pre><code>// Example of subscribing to the OnServerPeerDisconnected event\nNetworkManager.OnServerPeerDisconnected += (peer, phase) =&gt;\n{\n    switch (phase)\n    {\n        case Phase.Begin:\n            Debug.Log($\"Peer {peer.Id} is beginning the disconnection process.\");\n            break;\n        case Phase.Normal:\n            Debug.Log($\"Peer {peer.Id} is in the main disconnection phase.\");\n            break;\n        case Phase.End:\n            Debug.Log($\"Peer {peer.Id} has fully disconnected from the server.\");\n            break;\n    }\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnServerPeerDisconnected -= (peer, phase) =&gt;\n{\n    Debug.Log($\"Listener for peer {peer.Id} disconnection at phase {phase} removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onclientconnected","title":"OnClientConnected","text":"<p>An event that is triggered when the client successfully connects to the server.</p> <ul> <li>Signature: <code>public static event Action OnClientConnected</code></li> </ul> <p>Description</p> <p>The <code>OnClientConnected</code> event is invoked when the client establishes a successful connection with the server. This event allows developers to execute custom logic upon client connection, such as initializing UI elements, loading player data, or notifying the user of the connection status.</p> Example C#<pre><code>// Example of subscribing to the OnClientConnected event\nNetworkManager.OnClientConnected += () =&gt;\n{\n    Debug.Log(\"Client successfully connected to the server.\");\n    // Additional connection setup code here\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnClientConnected -= () =&gt;\n{\n    Debug.Log(\"Client connection listener removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onclientdisconnected","title":"OnClientDisconnected","text":"<p>An event that is triggered when the client disconnects from the server, providing a message with the disconnection reason.</p> <ul> <li>Signature: <code>public static event Action&lt;string&gt; OnClientDisconnected</code></li> </ul> <p>Description</p> <p>The <code>OnClientDisconnected</code> event is invoked when the client disconnects from the server. This event provides a string message detailing the reason for disconnection, allowing developers to display informative messages to users, handle cleanup tasks, or attempt reconnection based on the disconnection reason.</p> <p>Event Parameters</p> Parameter Type Description <code>string</code> <code>string</code> A message explaining the disconnection reason. Example C#<pre><code>// Example of subscribing to the OnClientDisconnected event\nNetworkManager.OnClientDisconnected += (reason) =&gt;\n{\n    Debug.Log($\"Client disconnected: {reason}\");\n    // Additional disconnection handling code here\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnClientDisconnected -= (reason) =&gt;\n{\n    Debug.Log(\"Client disconnection listener removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onclientidentityspawned","title":"OnClientIdentitySpawned","text":"<p>An event that is triggered when a <code>NetworkIdentity</code> is spawned on the client, providing access to the spawned identity.</p> <ul> <li>Signature: <code>public static event Action&lt;NetworkIdentity&gt; OnClientIdentitySpawned</code></li> </ul> <p>Description</p> <p>The <code>OnClientIdentitySpawned</code> event is invoked whenever a <code>NetworkIdentity</code> is successfully spawned on the client. This event provides the spawned <code>NetworkIdentity</code> instance, allowing developers to perform setup, initialize components, or trigger gameplay elements related to the spawned entity.</p> <p>Event Parameters</p> Parameter Type Description <code>NetworkIdentity</code> <code>NetworkIdentity</code> The network identity that was spawned. Example C#<pre><code>// Example of subscribing to the OnClientIdentitySpawned event\nNetworkManager.OnClientIdentitySpawned += (identity) =&gt;\n{\n    Debug.Log($\"Network identity spawned on client: {identity.name}\");\n    // Additional setup or initialization for the spawned identity\n};\n\n// Example of unsubscribing from the event\nNetworkManager.OnClientIdentitySpawned -= (identity) =&gt;\n{\n    Debug.Log(\"Client identity spawn listener removed.\");\n};\n</code></pre>"},{"location":"api_reference/#onmessageclient","title":"OnMessage(Client)","text":"<p>Represents an event that is triggered when a custom message is received by the client, providing the message ID, data buffer, and sequence channel.</p> <ul> <li>Signature: <code>public static event Action&lt;byte, DataBuffer, int&gt; OnMessage</code></li> </ul> <p>Description</p> <p>The <code>OnMessage</code> event is invoked whenever the client receives a custom message. This event provides access to the message ID, the data buffer containing the message content, and the sequence channel. Developers can subscribe to <code>OnMessage</code> to handle incoming messages, enabling custom message processing and response handling on the client side.</p> <p>Event Parameters</p> Parameter Type Description <code>byte</code> <code>byte</code> The ID of the received message. <code>DataBuffer</code> <code>DataBuffer</code> The data buffer containing the message content. <code>int</code> <code>int</code> The sequence channel used for message ordering consistency. Example C#<pre><code>// Example of subscribing to the OnMessage event to handle incoming messages\nNetworkManager.Client.OnMessage += (msgId, dataBuffer, sequenceChannel) =&gt;\n{\n    Debug.Log($\"Received message {msgId} on sequence channel {sequenceChannel}\");\n    // Process dataBuffer as needed\n};\n\n// Example of unsubscribing from the event\nNetworkManager.Client.OnMessage -= (msgId, dataBuffer, sequenceChannel) =&gt;\n{\n    Debug.Log($\"Unsubscribed from message {msgId}\");\n};\n</code></pre>"},{"location":"api_reference/#onmessageserver","title":"OnMessage(Server)","text":"<p>An event that is triggered when a custom message is received by the server, providing access to the message ID, data buffer, originating peer, and sequence channel.</p> <ul> <li>Signature: <code>public static event Action&lt;byte, DataBuffer, NetworkPeer, int&gt; OnMessage</code></li> </ul> <p>Description</p> <p>The <code>OnMessage</code> event is invoked when the server receives a custom message, allowing developers to handle the incoming message data. This event provides the message ID, data content, the peer who sent the message, and the sequence channel used to manage message ordering. It serves as an interface for handling various types of client-server communication in a flexible manner.</p> <p>Event Parameters</p> Parameter Type Description <code>byte</code> <code>byte</code> The ID of the received message. <code>DataBuffer</code> <code>DataBuffer</code> The data buffer containing the message content. <code>NetworkPeer</code> <code>NetworkPeer</code> The peer who sent the message. <code>int</code> <code>int</code> The sequence channel used for message ordering and consistency. Example C#<pre><code>// Example of subscribing to the OnMessage event\nNetworkManager.Server.OnMessage += (msgId, dataBuffer, peer, sequenceChannel) =&gt;\n{\n    Debug.Log($\"Received message {msgId} from peer {peer.Id} on sequence channel {sequenceChannel}\");\n    // Process dataBuffer as needed\n};\n\n// Example of unsubscribing from the event\nNetworkManager.Server.OnMessage -= (msgId, dataBuffer, peer, sequenceChannel) =&gt;\n{\n    Debug.Log($\"Unsubscribed from custom message {msgId}\");\n};\n</code></pre>"},{"location":"communication/","title":"Communication","text":""},{"location":"communication/#rpc-remote-procedure-call","title":"RPC (Remote Procedure Call)","text":"<p>RPCs (Remote Procedure Calls) are a standard software industry concept that allows methods to be called on objects that are not in the same executable. They enable communication between different processes or systems over a network.</p> <p>With RPCs, a server can invoke functions on a client, and similarly, a client can invoke functions on a server. This bi-directional communication allows for flexible and dynamic interactions between clients and servers, facilitating various operations such as requesting data, executing commands, and synchronizing states across different parts of a distributed system. RPCs provide a powerful mechanism for enabling remote interactions and enhancing the functionality of networked applications.</p> <p>RPC Basic Structure</p> <p> <pre><code>graph LR\n  A[Ruan&lt;br&gt;___Local Player___] ---&gt; | User Input Rpc | B{Server}\n  B ---&gt; | Move Rpc | A\n  B ---&gt; | Move Rpc | C[Junior&lt;br&gt;___Remote Player___]\n  B ---&gt; | Move Rpc | D[Mike&lt;br&gt;___Remote Player___]</code></pre> </p> <p>The diagram illustrates the basic flow of an RPC (Remote Procedure Call) in a multiplayer environment.  </p> <p>RPC Flow</p> <ol> <li> <p>Local Player (Ruan)</p> <ul> <li>Sends input to server via RPC</li> <li>Receives validated updates back</li> </ul> </li> <li> <p>Server</p> <ul> <li>Validates input</li> <li>Broadcasts updates to all players</li> </ul> </li> <li> <p>Remote Players</p> <ul> <li>Receive server-validated updates</li> <li>Apply changes to maintain sync</li> </ul> </li> </ol> <p>RPC Naming Convention and Base Classes</p> <p>RPC's are also supported in base classes. If you are using a base class for network functionality, ensure that the base class name includes the <code>Base</code> prefix.</p> <p>Naming Convention</p> <p>Base classes using RPCs must include the <code>Base</code> suffix:</p> <ul> <li>\u2705 <code>PlayerBase</code></li> <li>\u2705 <code>CharacterBase</code> </li> <li>\u274c <code>BasePlayer</code></li> <li>\u274c <code>Player</code></li> </ul> Example C#<pre><code>public class PlayerBase : NetworkBehaviour // Note the \"Base\" prefix\n{\n    const byte FireRpcId = 1;\n\n    // 1. Define virtual RPCs here\n    [Client(FireRpcId)]\n    protected virtual void FireRpc()\n    {\n       Debug.Log(\"Fired from base class\");\n    }\n\n    void Update()\n    {\n        if (Input.GetKeyDown(KeyCode.Space))\n        {\n            if (IsServer)\n            {\n                // 2. Server invokes the RPC on the client\n                Server.Rpc(FireRpcId);\n            }\n        }\n    }\n}\n\npublic class Player : PlayerBase\n{\n    // 3. Implement the virtual RPC in the derived class\n    protected override void FireRpc()\n    {\n       Debug.Log(\"Fired from derived class\");\n    }\n}\n</code></pre> <p>Note</p> <p>Before proceeding, refer to the Communication Structure and Service Locator Pattern pages for essential background information.</p>"},{"location":"communication/#method-signature","title":"Method Signature","text":"<p>Remote Procedure Calls (RPCs) in our networking system allow communication between clients and servers. Each RPC method can be configured with different parameters to handle various networking scenarios.</p> <p>RPC methods can accept up to three parameters:</p> Parameter Description Availability <code>DataBuffer message</code> Contains the transmitted data Client &amp; Server <code>NetworkPeer peer</code> Information about the calling client Server Only <code>int seqChannel</code> Controls message ordering and priority Client &amp; Server <p>Remote Procedure Calls (RPCs) require proper method decoration with either:</p> <ul> <li><code>[Server]</code> - Marks a method that executes on the server when called by a client</li> <li><code>[Client]</code> - Marks a method that executes on clients when called by the server </li> </ul> <p>Each RPC method must specify a unique numeric ID between 1-230 within its class:</p> C#<pre><code>[Server(1)] // Method executes on server when invoked from client, using ID 1\nvoid MyServerMethod() { }\n\n[Client(2)] // Method executes on client when invoked from server, using ID 2  \nvoid MyClientMethod() { }\n</code></pre> <p>Here are all valid server RPC signatures, from simplest to most complex:</p>"},{"location":"communication/#server-side-signatures","title":"Server-Side Signatures","text":"Signature 1Signature 2Signature 3Signature 4 Basic RPC - No parameters C#<pre><code>public class Player : NetworkBehaviour\n{\n    [Server(1)]\n    void OnServerMethod()\n    {\n       // Handles simple server-side logic\n       // Use when no data transfer is needed\n    }\n}\n</code></pre> Data-only RPC C#<pre><code>public class Player : NetworkBehaviour\n{\n    [Server(1)]\n    void OnServerMethod(DataBuffer message)\n    {\n        // Handles incoming client data\n        // Example: Reading player input\n        var input = message.Read&lt;Vector2&gt;();\n    }\n}\n</code></pre> Data + Peer Info C#<pre><code>public class Player : NetworkBehaviour\n{\n    [Server(1)]\n    void OnServerMethod(DataBuffer message, NetworkPeer peer)\n    {\n       // Handles data with client identification\n       // Example: Processing authenticated requests\n       if ((bool)peer.Data[\"IsAuthenticated\"]) {\n           ProcessRequest(message);\n       }\n    }\n}\n</code></pre> Full Configuration C#<pre><code>public class Player : NetworkBehaviour\n{\n    [Server(1)]\n    void OnServerMethod(DataBuffer message, NetworkPeer peer, int seqChannel)\n    {\n       // Complete control over message handling\n       // Example: Priority-based game events\n    }\n}\n</code></pre> <p>Valid client RPC signatures with common use cases:</p>"},{"location":"communication/#client-side-signatures","title":"Client-Side Signatures","text":"Signature 1Signature 2Signature 3 Basic RPC - No parameters C#<pre><code>public class Player : NetworkBehaviour\n{\n    [Client(1)]\n    void OnClientMethod()\n    {\n        // Simple client-side updates\n        // Example: UI refreshes\n        UpdatePlayerUI();\n    }\n}\n</code></pre> Data-only RPC C#<pre><code>public class Player : NetworkBehaviour\n{\n    [Client(1)]\n    void OnClientMethod(DataBuffer message)\n    {\n        // Handle server data\n        // Example: Receiving game state\n        var position = message.Read&lt;Vector3&gt;();\n        UpdatePlayerPosition(position);\n    }\n}\n</code></pre> Data + Channel C#<pre><code>public class Player : NetworkBehaviour\n{\n    [Client(1)]\n    void OnClientMethod(DataBuffer message, int seqChannel)\n    {\n        // Ordered message processing\n        // Example: Animation sequences\n        ProcessAnimationSequence(message, seqChannel);\n    }\n}\n</code></pre> <p>RPC ID System</p> <p>\ud83d\udcdd Each RPC method requires a unique numeric identifier (ID) within its class:</p> <ul> <li>IDs are used for message routing between client and server</li> <li>Only needs to be unique within the same class</li> <li>Different classes can reuse the same IDs C#<pre><code>// Valid - Different classes can use same ID\npublic class PlayerSystem {\n    [Server(1)] void Method1() { }\n    [Server(2)] void Method2() { }  // \u2705 Unique within class\n}\n\npublic class InventorySystem {\n    [Server(1)] void Method1() { }  // \u2705 OK to reuse ID in different class\n}\n</code></pre></li> </ul> <p>ID Range Requirements</p> <p>\u26a0\ufe0f RPC IDs must follow these rules:</p> <ul> <li>Valid range: <code>1</code> to <code>230</code></li> <li>Cannot be zero or negative</li> <li>Cannot exceed 230 C#<pre><code>// Invalid ID examples\n[Server(0)]    void Invalid1() { }  // \u274c Zero not allowed\n[Server(-1)]   void Invalid2() { }  // \u274c Negative not allowed\n[Server(231)]  void Invalid3() { }  // \u274c Exceeds maximum\n\n// Valid ID example\n[Server(1)]    void Valid() { }     // \u2705 Correct usage\n</code></pre> \ud83d\udca5 Runtime Exception will be thrown if these rules are violated</li> </ul> <p>Use Constants for RPC IDs</p> <p>It's recommended to use constants for RPC IDs to improve code maintainability and prevent duplicate IDs. This makes it easier to manage and refactor RPC calls across your codebase.</p> Example C#<pre><code>public class Player : NetworkBehaviour\n{\n    private const byte MOVE_RPC_ID = 1;\n    private const byte ATTACK_RPC_ID = 2;\n    private const byte HEAL_RPC_ID = 3;\n\n    [Server(MOVE_RPC_ID)]\n    void MoveRpc() { }\n\n    [Server(ATTACK_RPC_ID)] \n    void AttackRpc() { }\n\n    [Server(HEAL_RPC_ID)]\n    void HealRpc() { }\n}\n</code></pre>"},{"location":"communication/#implementation-examples","title":"Implementation Examples","text":"Example 1 (NetworkBehaviour)Example 2 (ServerBehaviour &amp; ClientBehaviour)Example 3 (DualBehaviour) Example 1 (NetworkBehaviour) C#<pre><code>public class Player : NetworkBehaviour\n{\n    private const byte MOVEMENT_RPC = 1;\n\n    [Server(MOVEMENT_RPC)]\n    void UpdateMovementServer(DataBuffer message)\n    {\n       // server reads the client's movement data and broadcasts it to all clients\n        Vector3 position = message.Read&lt;Vector3&gt;();\n        Quaternion rotation = message.Read&lt;Quaternion&gt;();\n\n        // validate the data and send it to all clients\n\n        Server.Rpc(MOVEMENT_RPC, position, rotation);\n    }\n\n    [Client(MOVEMENT_RPC)]\n    void UpdateMovementClient(DataBuffer message)\n    {\n        // client receives the movement data from the server\n        Vector3 position = message.Read&lt;Vector3&gt;();\n        Quaternion rotation = message.Read&lt;Quaternion&gt;();\n\n        // update the player's position and rotation\n        transform.position = position;\n        transform.rotation = rotation;\n    }\n\n    void Update()\n    {\n        // Client authoritatively sends movement data to the server\n        if (IsLocalPlayer)\n        {\n            Client.Rpc(MOVEMENT_RPC, transform.position, transform.rotation);\n        }\n    }\n}\n</code></pre> Example 2 (ServerBehaviour &amp; ClientBehaviour) <p>Script ID Configuration</p> <p>Script IDs act as a bridge between client and server components, ensuring they can communicate properly. Each pair of corresponding client/server scripts must share the same ID in their Unity Inspector.</p> <p>Key Points:</p> <ul> <li>The ID links matching client and server components</li> <li>Must be unique across your project</li> <li>Set in Unity Inspector for both scripts</li> <li>Mismatched IDs will break communication</li> </ul> Example Text Only<pre><code>LoginServer.cs    -&gt; Script ID: 1  \u2713\nLoginClient.cs    -&gt; Script ID: 1  \u2713\n\nPlayerServer.cs   -&gt; Script ID: 2  \u2713 \nPlayerClient.cs   -&gt; Script ID: 2  \u2713\n</code></pre> C#<pre><code>// Server-side class for handling login requests\npublic class LoginServer : ServerBehaviour\n{\n    private const byte LOGIN_RPC = 1;\n\n    [Server(LOGIN_RPC)]\n    void LoginServer(DataBuffer message, NetworkPeer peer)\n    {\n        string username = message.ReadString();\n        string password = message.ReadString();\n\n        // Server-side login logic\n\n        // Send a response to the client\n        Server.Rpc(LOGIN_RPC, peer, Target.SelfOnly);\n    }\n}\n\n// Client-side class for handling login requests\npublic class LoginClient : ClientBehaviour\n{\n    private const byte LOGIN_RPC = 1;\n\n    [Client(LOGIN_RPC)]\n    void LoginClient()\n    {\n       print(\"Wow! you are logged in!\");\n    }\n\n    void Update()\n    {\n        // Client sends a login request to the server\n        if (Input.GetKeyDown(KeyCode.L))\n        {\n            using var message = Rent();\n            message.WriteString(\"username\");\n            message.WriteString(\"password\");\n            Client.Rpc(LOGIN_RPC, message);\n        }\n    }\n}\n</code></pre> Example 3 (DualBehaviour) C#<pre><code>public class Player : DualBehaviour\n{\n    [Server(1)]\n    void ExampleOnServer() // Signature 1\n    {\n       print(\"Wow! This works on the server!\");\n    }\n\n    [Client(1)]\n    void ExampleOnClient() // Signature 1\n    {\n       print(\"Wow! This works on the client!\");\n    }\n}\n</code></pre>"},{"location":"communication/#how-to-invoke-a-rpc","title":"How to Invoke a RPC","text":"<p>The <code>Client</code> and <code>Server</code> properties are part of the public API inherited from <code>NetworkBehaviour</code>, <code>ClientBehaviour</code>, <code>ServerBehaviour</code>, and <code>DualBehaviour</code>. </p> <p>They are designed to facilitate communication between client and server in the network environment. Each property enforces specific usage restrictions to ensure proper client-server interactions.</p> <p>The network components provide two key properties for managing client-server communication:</p> <p>Client Property</p> <ul> <li>Purpose: Enables clients to send RPCs to the server</li> <li>Access: Client-side only (throws exception if accessed on server)</li> <li>Main Method: <code>Rpc()</code> with multiple overloads</li> <li>Example Usage: C#<pre><code>// On client:\nusing var someData = Rent();\nsomeData.WriteString(\"Hello World!\");\n\nClient.Rpc(rpcId);              // Basic RPC\nClient.Rpc(rpcId, someData);    // RPC with data\nClient.Rpc(rpcId, someData, DeliveryMode.ReliableOrdered); // RPC with data and delivery mode\nClient.Rpc(rpcId, someData, DeliveryMode.ReliableOrdered, 10); // RPC with data, delivery mode, and sequence channel\nClient.Rpc(rpcId, transform.position, transform.rotation, new ClientOptions() {}); // RPC with unmanaged types\n</code></pre></li> </ul> <p>Server Property</p> <ul> <li>Purpose: Enables server to send RPCs to clients</li> <li>Access: Server-side only (throws exception if accessed on client) </li> <li>Main Method: <code>Rpc()</code> with multiple overloads</li> <li>Example Usage: C#<pre><code>// On server:\nusing var data = Rent();\ndata.WriteString(\"Hello World!\");\n\nServer.Rpc(rpcId);                    // Broadcast to all(default)\nServer.Rpc(rpcId, data, Target.All);  // Targeted broadcast\nServer.Rpc(rpcId, data, Target.AllExceptSelf, DeliveryMode.ReliableOrdered); // Targeted broadcast with delivery mode\nServer.Rpc(rpcId, data, Target.GroupOnly, DeliveryMode.ReliableOrdered, 10); // Targeted broadcast with delivery mode and sequence channel\nServer.Rpc(rpcId, transform.position, transform.rotation, new ServerOptions() { \n    Target = Target.SelfOnly \n}); // RPC with unmanaged types\n</code></pre></li> </ul> <p>Both properties enforce proper client-server architecture by restricting access to the appropriate side. For detailed API information including all overloads, see the API Reference.</p> Example 1 (NetworkBehaviour) - Send an RPC from the client to the serverExample 2 (NetworkBehaviour) - Send an RPC from the server to the client Example 1 (NetworkBehaviour) - Send an RPC from the client to the server C#<pre><code>public class Player : NetworkBehaviour\n{\n    void Update()\n    {\n       // Send an RPC from the client to the server\n       if (Input.GetKeyUp(KeyCode.S) &amp;&amp; IsLocalPlayer)\n       {\n           Client.Rpc(1);\n       }\n    }\n\n    [Server(1)]\n    void Example() // Signature 1\n    {\n       print(\"Wow! This works on the server!\");\n    }\n}\n</code></pre> Example 2 (NetworkBehaviour) - Send an RPC from the server to the client C#<pre><code>public class Player : NetworkBehaviour\n{\n    void Update()\n    {\n       // Send an RPC from the server to the client\n       if (Input.GetKeyUp(KeyCode.A) &amp;&amp; IsServer)\n       {\n           Server.Rpc(1);\n       }\n    }\n\n    [Client(1)]\n    void Example() // Signature 1\n    {\n       print(\"Wow! This works on the client!\");\n    }\n}\n</code></pre> <p><code>Rpc()</code> with arguments:</p> <p>Tip</p> <p>The <code>Client.Rpc()</code> and <code>Server.Rpc()</code> methods has 8 overloads and optional arguments. However, the overloads available can vary depending on the network base class used(i.e. <code>NetworkBehaviour</code>, <code>ClientBehaviour</code>, <code>ServerBehaviour</code>, and <code>DualBehaviour</code>). </p> <p>For details on the available overloads, please refer to the API Reference.</p> Client-SideServer-Side Client-Side C#<pre><code>public class Player : NetworkBehaviour\n{\n    void Update()\n    {\n       // Send an RPC from the client to the server\n       if (Input.GetKeyUp(KeyCode.S) &amp;&amp; IsLocalPlayer)\n       {\n           using DataBuffer message = Rent();\n           message.WriteString(\"Hello World!\");\n           message.Write(123f);\n           Client.Rpc(1, message, DeliveryMode.ReliableOrdered);\n       }\n    }\n\n    [Server(1)]\n    void Example(DataBuffer message) // Signature 2\n    {\n       string str = message.ReadString();\n       float num = message.Read&lt;float&gt;();\n       Debug.Log(str + \" \" + num);\n    }\n}\n</code></pre> Server-Side C#<pre><code>public class Player : NetworkBehaviour\n{\n    void Update()\n    {\n       // Send an RPC from the server to the client\n       if (Input.GetKeyUp(KeyCode.A) &amp;&amp; IsServer)\n       {\n           using DataBuffer message = Rent();\n           message.WriteString(\"Hello World!\");\n           message.Write(123f);\n           Server.Rpc(1, message, Target.All, DeliveryMode.ReliableOrdered);\n       }\n    }\n\n    [Client(1)]\n    void Example(DataBuffer message) // Signature 2\n    {\n       string str = message.ReadString();\n       float num = message.Read&lt;float&gt;();\n       Debug.Log(str + \" \" + num);\n    }\n}\n</code></pre> <p>Direct Value Transmission</p> <p>RPCs support direct sending of primitive and unmanaged types without manual <code>DataBuffer</code> creation.</p> <p>Supported Types</p> <ul> <li>Primitives (<code>int</code>, <code>float</code>, <code>bool</code>, etc)</li> <li>Unity types (<code>Vector3</code>, <code>Quaternion</code>, etc)</li> <li>Blittable structs</li> </ul> <p>Examples C#<pre><code>// Client-side examples\nClient.Rpc(rpcId, 42);                     // Single int\nClient.Rpc(rpcId, true, 3.14f, 23.3d);           // Multiple primitives\nClient.Rpc(rpcId, transform.position, transform.rotation, Vector3.Zero, new ClientOptions() {});     // Unity type\n\n// Server-side examples with options\nServer.Rpc(rpcId, Vector3.zero, new ServerOptions {\n    DeliveryMode = DeliveryMode.Unreliable\n});\n\nServer.Rpc(rpcId, transform.position, transform.rotation, 100f, new ServerOptions {\n    Target = Target.AllExceptSelf\n    DeliveryMode = DeliveryMode.Unreliable,\n});\n</code></pre></p> <p>Type Restrictions</p> <p>\u274c Not Allowed Without a <code>DataBuffer</code>:</p> <ul> <li>Reference types</li> <li>Classes</li> <li>Arrays</li> <li>Strings</li> </ul> <p>\u2705 Allowed:</p> <ul> <li>Primitive types</li> <li>Unmanaged structs</li> <li>Unity value types</li> </ul>"},{"location":"communication/#network-variables","title":"Network Variables","text":"<p>A <code>[NetworkVariable]</code> is a powerful attribute that automatically synchronizes state between server and clients without manual RPC implementation. When a network variable's value changes on the server, the framework automatically propagates these changes to all connected clients, ensuring state consistency across the network.</p> <p>Key benefits:</p> <ul> <li>Automatic synchronization without manual networking code</li> <li>Significantly reduces boilerplate compared to RPCs</li> <li>Change detection and validation out of the box</li> </ul> <p>This provides an efficient way to maintain synchronized game state with minimal code overhead.</p> <p>Network Variable Structure</p> <p> <pre><code>graph LR\n  Ref{Game Object&lt;br&gt;___Server Side___} --&gt; | Health Change | A{RPC}\n  A ---&gt; | Health Update | B[Mike&lt;br&gt;___Client Side___]\n  A ---&gt; | Health Update | C[Ruan&lt;br&gt;___Client Side___]</code></pre> </p> <p>The diagram illustrates how a Network Variable operates in a multiplayer environment:</p> <ul> <li>A server-side game object modifies a variable (e.g., <code>Health</code>).</li> <li>This change is processed by the server, which acts as the authoritative source.</li> <li>The server then sends updates to all connected clients (e.g., Mike and Ruan), ensuring that each client reflects the latest value of the variable.</li> <li>These updates allow all players to have a synchronized and consistent view of the variable's state, regardless of who initiated the change or their connection latency.</li> </ul> <p>This structure highlights the server's role in maintaining authority and consistency across the network.</p>"},{"location":"communication/#base-class-support","title":"Base Class Support","text":"<p>Network Variables support inheritance through base classes, allowing you to define shared networked state that derived classes can access and modify.</p> <p>Base Class Naming Convention</p> <p>When using Network Variables in base classes:</p> <ul> <li>Base class names must end with the <code>Base</code> suffix</li> <li>The suffix is required for proper code generation</li> <li>Incorrect naming will prevent network synchronization</li> </ul> Valid Base Class Names C#<pre><code>\u2705 PlayerBase\n\u2705 CharacterBase\n\u2705 VehicleBase\n\u274c BasePlayer    // Incorrect - 'Base' must be suffix\n\u274c Player       // Missing 'Base' suffix\n</code></pre> Base Class Implementation C#<pre><code>public partial class CharacterBase : NetworkBehaviour \n{\n    [NetworkVariable]\n    private float m_Health = 100f;  // Base class network variable\n\n    protected virtual void OnHealthChanged(float prev, float next, bool isWriting)\n    {\n        Debug.Log($\"Health changed from {prev} to {next}\");\n    }\n}\n\npublic partial class Player : CharacterBase  // Inherits network variable\n{\n    protected override void OnHealthChanged(float prev, float next, bool isWriting)\n    {\n        base.OnHealthChanged(prev, next, isWriting);\n        UpdateHealthUI(next);  // Add custom behavior\n    }\n}\n</code></pre> <p>Network Variables defined in base classes are automatically available to all derived classes, maintaining synchronization across the inheritance chain while allowing customization through virtual hooks.</p> <p>Note</p> <p>Before proceeding, refer to the Communication Structure and Service Locator Pattern pages for essential background information.</p>"},{"location":"communication/#how-to-use","title":"How to Use","text":"<p>Network Variable Inspector</p> <p>Network variables are automatically displayed in the Unity Inspector even without the <code>[SerializeField]</code> attribute. However, without this attribute they are read-only and not serialized.</p> <p>To make network variables both visible and editable in the Inspector:</p> <ul> <li>Add both <code>[NetworkVariable]</code> and <code>[SerializeField]</code> attributes</li> <li>This enables full serialization and editing capabilities</li> <li>Without <code>[SerializeField]</code>, values reset on scene reload</li> </ul> Example C#<pre><code>public partial class Player : NetworkBehaviour \n{\n    [NetworkVariable]\n    [SerializeField] // Required for Inspector editing\n    private float m_Health = 100f;\n\n    [NetworkVariable] // Displayed, but Read-only in Inspector\n    private float m_Stamina = 100f; \n}\n</code></pre> <p>Network Variable Naming Requirements</p> <p>Field Naming Convention</p> <p>Network variable fields must follow these rules:</p> <ol> <li>Fields must be prefixed with <code>m_</code></li> <li>First letter after prefix must be capitalized</li> <li>Class must be marked as <code>partial</code></li> </ol> <p>\u2705 Valid Examples: C#<pre><code>public partial class Player : NetworkBehaviour \n{\n    [NetworkVariable]\n    private float m_Health = 100f;  // Correct prefix and capitalization\n\n    [NetworkVariable]\n    private Vector3 m_Position;      // Correct format\n}\n</code></pre></p> <p>\u274c Invalid Examples: C#<pre><code>public class Player : NetworkBehaviour // Missing partial\n{\n    [NetworkVariable]\n    private float health;      // Missing m_ prefix\n\n    [NetworkVariable]\n    private float m_mana;      // Lowercase after prefix\n}\n</code></pre></p> <p>Why partial?</p> <p>The <code>partial</code> keyword is required because the source generator needs to extend the class with additional generated code for network variable functionality.</p> <p>Network Variable Source Generation</p> <p>The <code>Omni Source Generator</code> automatically generates several elements for each <code>[NetworkVariable]</code>:</p> <p>Properties:</p> <ul> <li>Public property for accessing the variable</li> <li>Getter/setter with network synchronization</li> </ul> <p>Hooks:</p> <ul> <li><code>OnVariableChanged</code> method for value change detection</li> <li><code>partial void</code> hooks for custom change handling</li> <li>Base class override hooks with <code>protected virtual</code> methods</li> </ul> <p>Options:</p> <ul> <li>Variable-specific network options (e.g., <code>HealthOptions</code>)</li> <li>Customizable delivery modes and target options</li> <li>Serialization and synchronization settings</li> </ul> <p>Methods:</p> <ul> <li>Manual sync methods (e.g., <code>SyncHealth()</code>)</li> <li>Value validation methods</li> <li>Networking utility methods</li> </ul> <p>Example of generated elements for a health variable: C#<pre><code>// Generated property\npublic float Health { get; set; }\n\n// Generated hook\npartial void OnHealthChanged(float prev, float next, bool isWriting);\nvirtual void OnHealthChanged(float prev, float next, bool isWriting);\n\n// Generated options\npublic NetworkVariableOptions HealthOptions { get; set; }\n\n// Generated sync method\npublic void SyncHealth(NetworkVariableOptions options);\n</code></pre></p>"},{"location":"communication/#generated-properties","title":"Generated Properties","text":"<p>Generated properties in Omni are designed to automatically synchronize their values across the server and all connected clients each time the property is modified. This ensures that all instances of the property remain consistent throughout the networked environment, maintaining real-time accuracy.</p> <p>Warning</p> <p>Omni does not perform checks to determine if the new value is different from the current value. Each time the property\u2019s <code>setter</code> is invoked, the value is synchronized across the network, regardless of whether it has changed. This can lead to unnecessary network updates if the property is set to the same value repeatedly, so it is recommended to manage calls to the setter carefully to optimize performance.</p> Automatically Synchronized C#<pre><code>public partial class Player : NetworkBehaviour\n{\n    [NetworkVariable] \n    private float m_Health = 100f;\n    [NetworkVariable] \n    private float m_Mana = 100f;\n\n    void Update()\n    {\n       if(IsServer &amp;&amp; Input.GetKeyUp(KeyCode.N))\n       {\n          // Automatically synchronized\n          Health -= 10f;\n          Mana += 10f;\n       }\n    }\n}\n</code></pre> <p>Tip</p> <p>You can modify the underlying field directly instead of the property if you don\u2019t want automatic synchronization. To manually synchronize the modified field, simply call:</p> <ul> <li><code>SyncHealth(DefaultNetworkVariableOptions)</code></li> <li><code>SyncMana(DefaultNetworkVariableOptions)</code></li> </ul> <p>for immediate network updates.</p> Manually Synchronized C#<pre><code>public partial class Player : NetworkBehaviour\n{\n    [NetworkVariable] \n    private float m_Health = 100f;\n\n    void Update()\n    {\n        if(IsServer &amp;&amp; Input.GetKeyUp(KeyCode.N))\n        {\n            // Manually synchronized\n            m_Health -= 10f;\n            SyncHealth();\n        }\n    }\n}\n</code></pre> <p>Warning</p> <p>If you modify a field immediately after instantiating a networked object or within <code>Awake()</code> or <code>Start()</code>, the variable will synchronize correctly. This is because, during object initialization, the server automatically sends updates for network variables to clients. However, if you modify the property instead of the field at these early stages, synchronization may fail. Property changes trigger an update message, but if the object has not yet been instantiated on the client side, the update will not be applied.</p> <p>Bug</p> <p>Occasionally, generated code may not be recognized by the IDE\u2019s IntelliSense (e.g., in Visual Studio). If this occurs, a simple restart of the IDE should resolve the issue.</p>"},{"location":"communication/#default-behaviour","title":"Default Behaviour","text":"<p>Tip</p> <p>Use <code>DefaultNetworkVariableSettings</code> to adjust how network variables are transmitted across the network. This allows for configuring default behaviors for all network variables. For more specific control, you can use individual settings like <code>HealthOptions</code> and <code>ManaOptions</code> to customize the transmission behavior of specific variables.</p> Example C#<pre><code>public partial class Player : NetworkBehaviour\n{\n    [NetworkVariable] \n    private float m_Health = 100f;\n\n    [NetworkVariable] \n    private float m_Mana = 100f;\n\n    protected override void OnAwake()\n    {\n        // Change the default settings for all network variables\n        DefaultNetworkVariableOptions = new()\n        {\n            DeliveryMode = DeliveryMode.ReliableOrdered,\n            Target = Target.AllExceptSelf\n        };\n\n        // Change specific settings for specific network variables\n        HealthOptions = new()\n        {\n            DeliveryMode = DeliveryMode.ReliableOrdered,\n            Target = Target.All\n        };\n\n        ManaOptions = new()\n        {\n            DeliveryMode = DeliveryMode.ReliableOrdered,\n            Target = Target.All\n        };\n    }\n}\n</code></pre>"},{"location":"communication/#generated-methods","title":"Generated Methods","text":"<p>The <code>[NetworkVariable]</code> attribute will generate methods for each network variable, such as:</p> Health HookMana Hook Health Hook C#<pre><code>// Hook in the same script.\npartial void OnHealthChanged(float prevHealth, float nextHealth, bool isWriting)\n{\n    // The isWriting parameter indicates whether the operation is writing the value to the network or reading it from the network.\n}\n\n// Hook in the derived class.\nprotected override void OnBaseHealthChanged(float prevHealth, float nextHealth, bool isWriting)\n{\n    // The isWriting parameter indicates whether the operation is writing the value to the network or reading it from the network.\n}\n</code></pre> Mana Hook C#<pre><code>// Hook in the same script.\npartial void OnManaChanged(float prevMana, float nextMana, bool isWriting)\n{\n    // The isWriting parameter indicates whether the operation is writing the value to the network or reading it from the network.\n}    \n\n// Hook in the derived class.\nprotected override void OnBaseManaChanged(float prevMana, float nextMana, bool isWriting)\n{\n    // The isWriting parameter indicates whether the operation is writing the value to the network or reading it from the network.\n}\n</code></pre> <ul> <li><code>void SyncHealth(NetworkVariableOptions options);</code></li> </ul> <p>Manually synchronizes the <code>m_Health</code> field, allowing control over when and how this field is updated across the network.</p> <ul> <li><code>void SyncMana(NetworkVariableOptions options);</code> </li> </ul> <p>Manually synchronizes the <code>m_Mana</code> field.</p>"},{"location":"communication/#routex","title":"RouteX","text":"<p>RouteX is a simple simulation of <code>Express.js</code> and is one of the most useful features of the API. It can be easily used to request a route and receive a response from the server. Routes can also send responses to multiple clients beyond the one that originally requested the route.</p>"},{"location":"communication/#registering-routes","title":"Registering Routes","text":"<ol> <li>Import the <code>RouteX</code> module with <code>using static Omni.Core.RouteX;</code> and <code>Omni</code> with <code>using Omni.Core;</code></li> <li>Register the routes on the <code>Awake</code> method or on the <code>Start</code> method, eg:</li> </ol> <p>Note</p> <p><code>RouteX</code> supports both asynchronous and synchronous operations, providing flexibility for various use cases. All functions include asynchronous versions workflows. For additional overloads, detailed explanations, and further information on synchronous and asynchronous versions, consult the <code>API Reference</code>.</p> Registering a Get RouteRegistering a Post Route Example C#<pre><code>public class LoginControllerInServer : ServerBehaviour\n{\n   protected override void OnAwake()\n   {\n      XServer.GetAsync(\"/login\", (res) =&gt;\n      {\n          res.WriteString(\"Wow! You are logged in!\");\n          res.Send();\n      });\n\n      XServer.GetAsync(\"/register\", (res, peer) =&gt; // Peer argument is optional\n      {\n          res.WriteString(\"Ok! You are registered!\");\n          res.Send();\n      });\n   }\n}\n</code></pre> Example C#<pre><code>public class LoginControllerInServer : ServerBehaviour\n{\n   protected override void OnAwake()\n   {\n      XServer.PostAsync(\"/login\", (req, res) =&gt;\n      {\n          // Read the username sent in the request\n          string username = req.ReadString();\n\n          // Send a response\n          res.WriteString(\"Wow! You are logged in as \" + username);\n          res.Send();\n      });\n\n      XServer.PostAsync(\"/register\", (req, res, peer) =&gt; // Peer argument is optional\n      {\n          // Read the username sent in the request\n          string username = req.ReadString();\n\n          // Send a response\n          res.WriteString(\"Ok! You are registered!\");\n          res.Send();\n      });\n   }\n}\n</code></pre>"},{"location":"communication/#requesting-routes","title":"Requesting Routes","text":"Requesting a Get RouteRequesting a Post Route Example C#<pre><code>public class LoginControllerInClient : ClientBehaviour\n{\n   async void Update()\n   {\n      if (Input.GetKeyDown(KeyCode.R))\n      {\n          using DataBuffer res = await XClient.GetAsync(\"/login\");\n          string message = res.ReadString();\n          print(message);\n      }\n   }\n}\n</code></pre> Example C#<pre><code>public class LoginControllerInClient : ClientBehaviour\n{\n   async void Update()\n   {\n      if (Input.GetKeyDown(KeyCode.R))\n      {\n          using DataBuffer res = await XClient.PostAsync(\"/login\", req =&gt;\n          {\n              req.WriteString(\"John Doe\");\n          });\n\n          string message = res.ReadString();\n          print(message);\n      }\n   }\n}\n</code></pre> <p>Info</p> <p>Omni provides the <code>HttpResponse</code> and <code>HttpResponse&lt;T&gt;</code> objects to streamline the process of sending responses. These objects allow you to include a status code, a message, and optionally, a payload (via the generic version). This approach offers a more organized and structured way to handle and send responses in your application.</p> Registering a Post Route with HttpResponseRequesting a Post Route with HttpResponse Example C#<pre><code>public class LoginControllerInServer : ServerBehaviour\n{\n   protected override void OnAwake()\n   {\n      XServer.PostAsync(\"/login\", (req, res) =&gt;\n      {\n          // Read the username sent in the request\n          string username = req.ReadString();\n\n          // Send a response with HttpResponse\n          res.WriteHttpResponse(new HttpResponse()\n          {\n             StatusCode = StatusCode.Success,\n             StatusMessage = $\"Login successful, Hello {username}!\",\n          });\n\n          res.Send();\n      });\n\n      XServer.PostAsync(\"/getinfo\", (req, res) =&gt;\n      {\n          // Read the username sent in the request\n          string username = req.ReadString();\n\n          // Send a response with HttpResponse and payload\n          res.WriteHttpResponse(new HttpResponse&lt;Player&gt;()\n          {\n             StatusCode = StatusCode.Success,\n             StatusMessage = $\"Login successful, Hello {username}!\",\n             Result = new Player()\n          });\n\n          res.Send();\n      });\n   }\n}\n</code></pre> Example C#<pre><code>public class LoginControllerInClient : ClientBehaviour\n{\n   async void Update()\n   {\n      if (Input.GetKeyDown(KeyCode.R))\n      {\n          using DataBuffer res = await XClient.PostAsync(\"/login\", req =&gt;\n          {\n              req.WriteString(\"John Doe\");\n          });\n\n          var response = res.ReadHttpResponse();\n          print(response.StatusMessage);\n      }\n\n      if (Input.GetKeyDown(KeyCode.G))\n      {\n          using DataBuffer res = await XClient.PostAsync(\"/getinfo\", req =&gt;\n          {\n              req.WriteString(\"John Doe\");\n          });\n\n          var response = res.ReadHttpResponse&lt;Player&gt;();\n          print(\"Player name: \" + response.Result.Name);\n      }\n   }\n}\n</code></pre> <p>For more details, refer to the API Reference.</p>"},{"location":"communication/#serialization-and-deserialization","title":"Serialization and Deserialization","text":"<p>Omni supports serialization of a wide range of data types, including primitives, complex classes, structs, dictionaries, and more, providing unmatched flexibility for networked data structures. Omni offers two serialization methods: JSON-based serialization for readability and compatibility, and binary-based serialization for optimized performance and minimized data size.</p> <p>With Omni, everything is serializable. All network operations utilize the <code>DataBuffer</code> object, a dedicated data buffer that efficiently handles data preparation and transmission across the network, ensuring seamless and effective communication.</p> <p>Info</p> <p>The <code>DataBuffer</code> is the core of all Omni operations. It is used universally across RPCs, RouteX, custom messages, and other network features. Understanding how to manage and utilize <code>DataBuffer</code> is essential for working effectively with Omni.</p> <p>Danger</p> <p>As a binary serializer, <code>DataBuffer</code> requires that the order of reading matches the order of writing precisely. Any discrepancy in the read/write sequence can lead to corrupted or unexpected data. Developers should ensure consistency and adherence to the defined structure when serializing and deserializing data with <code>DataBuffer</code>.</p> <p>Info</p> <p>The <code>DataBuffer</code> functions similarly to a combination of <code>MemoryStream</code> and <code>BinaryWriter</code> and <code>BinaryReader</code>. It includes comparable properties and features, such as <code>Position</code>, enabling developers to efficiently manage and navigate the buffer while performing read and write operations.</p>"},{"location":"communication/#primitives","title":"Primitives","text":"<p>Omni\u2019s <code>DataBuffer</code> provides efficient support for primitive types, allowing direct serialization of commonly used data types such as integers, floats, and booleans. This simplifies network data handling by enabling fast read and write operations for foundational data types.</p> <p>Using these primitives, Omni ensures minimal overhead in data serialization, making it suitable for high-performance networking where lightweight data handling is essential. Primitive types can be written to or read from the <code>DataBuffer</code> in a straightforward manner, supporting rapid data transmission across client-server boundaries.</p> Writing PrimitivesReading Primitives Writing Primitives C#<pre><code>void Example()\n{\n   DataBuffer message = new DataBuffer();\n   message.Write(10); // Writes an integer value to the buffer\n   message.Write(3.14f); // Writes a floating-point value to the buffer\n   message.Write(true); // Writes a boolean value to the buffer\n}\n</code></pre> Reading Primitives C#<pre><code>void Example()\n{\n   DataBuffer message = GetHypotheticalValidDataBuffer();\n   int num = message.Read&lt;int&gt;(); // Reads an integer value from the buffer\n   float f = message.Read&lt;float&gt;(); // Reads a floating-point value from the buffer\n   bool b = message.Read&lt;bool&gt;(); // Reads a boolean value from the buffer\n}\n</code></pre>"},{"location":"communication/#complex-types","title":"Complex Types","text":"<p>Omni supports the serialization of complex types using <code>Newtonsoft.JSON</code> or <code>MemoryPack</code>. For objects and data structures that go beyond primitive types, JSON serialization provides a readable, flexible format ideal for compatibility with third-party systems, while <code>MemoryPack</code> enables efficient binary serialization for high-performance network transfers.</p> <p>Using these serialization methods, Omni can seamlessly handle complex data types, such as custom <code>structs</code>, <code>classes</code>, <code>dictionaries</code>, and <code>nested structures</code>, ensuring that all necessary data is transmitted effectively and accurately across the network.</p> JSON SerializationMemoryPack SerializationJSON DeserializationMemoryPack Deserialization JSON Serialization C#<pre><code>public class Player\n{\n    public string name;\n    public int score;\n    public Dictionary&lt;string, int&gt; inventory;\n}\n\nvoid Example()\n{\n   Player player = new Player();\n\n   // Serialize the player object\n   DataBuffer message = new DataBuffer();\n   message.WriteAsJson(player);\n}\n</code></pre> MemoryPack Serialization C#<pre><code>[MemoryPackable]\npublic partial class Player\n{\n    public string name;\n    public int score;\n    public Dictionary&lt;string, int&gt; inventory;\n}\n\nvoid Example()\n{\n   Player player = new Player();\n\n   // Serialize the player object\n   DataBuffer message = new DataBuffer();\n   message.WriteAsBinary(player);\n}\n</code></pre> JSON Deserialization C#<pre><code>public class Player\n{\n    public string name;\n    public int score;\n    public Dictionary&lt;string, int&gt; inventory;\n}\n\nvoid Example()\n{\n   DataBuffer message = GetHypotheticalValidDataBuffer();\n   Player player = message.ReadAsJson&lt;Player&gt;(); // Deserializes to a Player object\n}\n</code></pre> MemoryPack Deserialization C#<pre><code>[MemoryPackable]\npublic partial class Player\n{\n    public string name;\n    public int score;\n    public Dictionary&lt;string, int&gt; inventory;\n}\n\nvoid Example()\n{\n   DataBuffer message = GetHypotheticalValidDataBuffer();\n   Player player = message.ReadAsBinary&lt;Player&gt;(); // Deserializes to a Player object\n}\n</code></pre> <p>Note</p> <p>See the <code>Newtonsoft.JSON</code> or <code>MemoryPack</code> documentation for more information about using annotation attributes to customize serialization and deserialization.</p> <p>Info</p> <p>When sending a <code>DataBuffer</code>, you will always receive a <code>DataBuffer</code> in response; it is not possible to send and receive data in any other way without using a <code>DataBuffer</code>, as all operations utilize it internally. You must also ensure that the reading and writing occur in the same order.</p>"},{"location":"communication/#compression","title":"Compression","text":"<p>The <code>DataBuffer</code> object in Omni supports efficient data compression, utilizing the <code>Brotli</code> and <code>LZ4</code> algorithms. These algorithms are designed to optimize network performance by reducing data size without significant overhead, ensuring faster transmission and lower bandwidth usage.</p> <ul> <li>Brotli: A highly efficient compression algorithm ideal for scenarios where maximum compression is needed, offering significant size reduction for complex or large datasets.</li> <li>LZ4: Focused on speed, <code>LZ4</code> provides fast compression and decompression, making it suitable for real-time applications that prioritize performance over compression ratio.</li> </ul> <p>With these options, Omni allows developers to tailor data compression to their specific needs, balancing speed and efficiency for various network scenarios.</p> CompressionDecompression Compression C#<pre><code>void Example()\n{\n   DataBuffer message = new DataBuffer();\n   message.WriteAsJson(GetHypotheticalLargePlayerObject());\n\n   // Compress the data\n   message.CompressRaw(); // Compress the current buffer\n}\n</code></pre> Decompression C#<pre><code>void Example()\n{\n   DataBuffer message = GetHypotheticalCompressedDataBuffer();\n\n   // Decompress the data\n   message.DecompressRaw(); // Decompress the current buffer\n\n   // Read the decompressed data\n   Player player = message.ReadAsJson&lt;Player&gt;();\n}\n</code></pre>"},{"location":"communication/#cryptography","title":"Cryptography","text":"<p>Omni employs <code>AES</code> encryption to secure data buffers, ensuring that sensitive information remains protected during network transmission. The cryptographic system is designed with flexibility and security in mind, offering both peer-specific and global encryption keys to handle various scenarios.</p> <p>Peer-Specific Encryption</p> <p>Each <code>peer</code> in the network is assigned its own unique encryption key. When a client (e.g., Client A) sends a message using its key, only that client can decrypt the message. This ensures a high level of security, as no other client can access the encrypted data. Peer-specific encryption is ideal for situations where private communication or data integrity is paramount.</p> <p>Info</p> <p>Encryption keys are exchanged between the client and server using <code>RSA</code>, a robust public-key cryptography algorithm. This ensures that the <code>AES</code> keys used for data encryption remain secure during transmission, as only the intended recipient can decrypt the exchanged keys. By combining <code>RSA</code> for key exchange with <code>AES</code> for data encryption, Omni provides a highly secure and efficient cryptographic system for multiplayer environments.</p> <p>Global Server Key</p> <p>In addition to peer-specific keys, Omni provides a global server encryption key. Unlike peer-specific keys, the global key can be used to encrypt and decrypt any data, including messages originating from other clients. This global key is managed by the server and allows for seamless handling of shared data, such as broadcasted messages or server-wide updates. It provides a flexible option for scenarios where universal decryption is required without compromising security.</p> <p>Key Features</p> <ul> <li>AES Encryption: Omni uses the <code>Advanced Encryption Standard (AES)</code> to ensure robust protection against unauthorized access.</li> <li>Peer-Specific Keys: Restrict decryption to the originating peer, enhancing data privacy.</li> <li>Global Server Key: Enable decryption of any data within the network, facilitating shared communication and server-driven operations.</li> <li>Flexibility: The dual-key system allows developers to tailor encryption strategies to the needs of their application, balancing security and convenience.</li> </ul> <p>Omni's cryptography framework ensures that all data transmitted across the network is secure, whether it's private peer-to-peer communication or broadcasted messages. By combining peer-specific encryption with a global server key, Omni provides a powerful and flexible system for managing encrypted data in multiplayer environments.</p> EncryptionDecryption Encryption C#<pre><code>void Example()\n{\n   DataBuffer message = new DataBuffer();\n   message.WriteAsJson(GetHypotheticalPlayerObject());\n\n   // Encrypt the data\n   message.EncryptRaw(NetworkManager.SharedPeer); // Use `ServerPeer` - Global Encryption Key\n\n   // e.g. Encrypt the data with a peer-specific key in client side...\n   // message.EncryptRaw(NetworkManager.LocalPeer);\n}\n</code></pre> Decryption C#<pre><code>void Example()\n{\n   DataBuffer message = GetHypotheticalEncryptedDataBuffer();\n\n   // Decrypt the data\n   message.DecryptRaw(NetworkManager.SharedPeer); // Use `ServerPeer` - Global Encryption Key\n\n   // e.g. Decrypt the data with a peer-specific key in server side...\n   // message.DecryptRaw(peer);\n\n   // Read the decrypted data\n   Player player = message.ReadAsJson&lt;Player&gt;();\n}\n</code></pre> <p>See the <code>API Reference</code> for more information about the <code>DataBuffer</code> and its usage.</p>"},{"location":"communication/#imessage-interface","title":"IMessage Interface","text":"<p>This interface, <code>IMessage</code>, can be implemented to customize the serialization and deserialization of a type when used within an RPC or <code>NetworkVariable</code>. By implementing <code>IMessage</code>, you define how data is written to and read from a <code>DataBuffer</code>, enabling greater control over data structure and format.</p> <p>The <code>IMessageWithPeer</code> interface extends <code>IMessage</code> to include additional properties, such as <code>SharedPeer</code> and <code>IsServer</code>, which are useful for managing encryption and authentication in networked communications. This extension provides enhanced flexibility for handling secure and authenticated messaging between server and client.</p> Example C#<pre><code>   public class PlayerStruct : IMessage\n   {\n      private string m_Name;\n      private Vector3 m_Position;\n      private int m_Health;\n      private int m_Mana;\n\n      public void Serialize(DataBuffer writer)\n      {\n        writer.WriteString(m_Name);\n        writer.Write(m_Position);\n        writer.Write(m_Health);\n        writer.Write(m_Mana);\n      }\n\n      public void Deserialize(DataBuffer reader)\n      {\n        m_Name = reader.ReadString();\n        m_Position = reader.Read&lt;Vector3&gt;();\n        m_Health = reader.Read&lt;int&gt;();\n        m_Mana = reader.Read&lt;int&gt;();\n      }\n   }\n</code></pre> Network VariableRPC Network Variable C#<pre><code>   public partial class Player : NetworkBehaviour\n   {\n      [NetworkVariable] \n      private PlayerStruct m_PlayerStruct = new PlayerStruct();\n   }\n</code></pre> RPC C#<pre><code>   public class Player : NetworkBehaviour\n   {\n       private PlayerStruct m_PlayerStruct = new PlayerStruct();\n\n       void Update()\n       {\n          if(IsServer)\n          {\n            // Send an RPC from the server to the client\n            Server.Rpc(1, m_PlayerStruct, new()\n            {\n                DeliveryMode = DeliveryMode.Unreliable\n            });\n          }\n       }\n\n       [Client(1)]\n       void Example(DataBuffer message) // Signature 2\n       {\n          m_PlayerStruct = message.Deserialize&lt;PlayerStruct&gt;();\n\n           // Alternative:\n          // Populate an existing object\n          // message.Populate(m_PlayerStruct);\n       }\n   }\n</code></pre>"},{"location":"database/","title":"Database System","text":"<p>Modified Database Libraries</p> <p>Omni Networking uses customized versions of SQLKata and Dapper modified for Unity:</p> <p>Improved:</p> <ul> <li>\u2728 Reduced memory allocations and garbage collector pressure</li> <li>\ud83d\udd04 Async/await support with Task/ValueTask/UniTask</li> <li>\u26a1 Added support for IL2CPP compilation</li> </ul> <p>These modifications ensure better performance and compatibility within Unity's ecosystem while maintaining the original libraries' ease of use.</p> <p>IL2CPP Compatibility</p> <p>Some database features may have limited compatibility when using IL2CPP compilation. However, all essential functionality remains available through alternative approaches supported by the Omni Networking framework.</p>"},{"location":"spawning/","title":"Spawning","text":""},{"location":"spawning/#overview","title":"Overview","text":"<p>Omni supports spawning objects on both the server and client, providing several methods for network object instantiation. In this guide, we\u2019ll walk you through the available options, from the simplest to the most advanced approaches, enabling you to choose the best method based on your project\u2019s requirements.</p> <p>Each method allows for a different level of control over networked objects, from basic automatic spawning to more complex, customizable instantiation processes.</p>"},{"location":"spawning/#simple-instantiation","title":"Simple Instantiation","text":"<p>The Network Object Spawner component provides a quick and efficient way to instantiate networked objects, making it ideal for prototyping stages. This component simplifies the process by automatically handling the instantiation of both prefabs and scene objects over the network. </p> <p>With Network Object Spawner, you can set up networked objects with minimal configuration, allowing you to focus on testing gameplay and mechanics rather than complex network setups.</p> <ul> <li>Add the <code>Network Object Spawner</code> component to any game object in your scene.</li> </ul> Field Description Local Player A <code>NetworkIdentity</code> reference for the object that will be controlled by the local player. This object will receive input and commands directly from the local player. Objects to Spawn A list of <code>NetworkIdentity</code> references for objects to be managed by the server. These objects will be instantiated over the network and controlled by the server. <p>Using this setup, the <code>Network Object Spawner</code> manages instantiation and synchronization, simplifying networked spawning for both player-controlled and server-managed objects.</p> <p>Tip</p> <p>You can add either a prefab or a scene object to the Local Player or Objects to Spawn list, depending on your project\u2019s requirements.</p>"},{"location":"spawning/#manual-instantiation","title":"Manual Instantiation","text":"<p>If you want to instantiate a networked object manually in a straightforward way, here are some examples to guide you. Manual instantiation provides you with more control over when and where the networked object appears in the scene, ideal for scenarios where specific logic or conditions dictate object creation. </p> <p>Follow these examples to quickly and easily get started with manual instantiation of networked objects in your project.</p> <p>First example:</p> C#<pre><code>   // Cache to store all spawn-related messages.\n   private DataCache m_SpawnCache = new DataCache(CachePresets.ServerNew);\n\n   protected override void OnServerPeerConnected(NetworkPeer peer, Phase phase)\n   {\n       // Ensure actions occur only after the client is fully connected and authenticated.\n       if (phase == Phase.End) // Phase.End: Indicates the client is authenticated and ready for network interactions\n       {\n           // Retrieve the first registered prefab from the NetworkManager\u2019s prefab list. \n           // Note: you can also use:\n           // var prefab = NetworkManager.GetPrefab(\"PrefabName\");\n           NetworkIdentity prefab = NetworkManager.GetPrefab(0);\n\n           // Spawn the prefab for the connected peer and pass the spawn cache\n           prefab.Spawn(peer, dataCache: m_SpawnCache);\n\n           // Send the cached spawn data to the connected peer, allowing late-joining players to \n           // receive all relevant spawn information and ensuring they have a consistent game state.\n           m_SpawnCache.SendToPeer(peer);\n       }\n   }\n</code></pre> <p>Tip</p> <ul> <li><code>NetworkManager.GetPrefab</code> offers two overloads: one for retrieving a prefab by its name and another for accessing a prefab by its index in the registered prefab list.</li> <li><code>prefab.Spawn</code> offers two overloads and optional arguments to control the spawn process.</li> </ul> <p>Check de API reference for more details.</p>"}]}